{"version":3,"file":"pixi-sound.js","sources":["../src/instance.ts","../node_modules/tslib/tslib.es6.js","../src/utils/supported.ts","../src/utils/resolveUrl.ts","../src/SoundLoader.ts","../src/htmlaudio/HTMLAudioInstance.ts","../src/htmlaudio/HTMLAudioMedia.ts","../src/SoundSprite.ts","../src/webaudio/WebAudioUtils.ts","../src/webaudio/WebAudioInstance.ts","../src/Filterable.ts","../src/webaudio/WebAudioNodes.ts","../src/webaudio/WebAudioMedia.ts","../src/Sound.ts","../src/htmlaudio/HTMLAudioContext.ts","../src/webaudio/WebAudioContext.ts","../src/SoundLibrary.ts","../src/htmlaudio/index.ts","../src/filters/Filter.ts","../src/filters/index.ts","../src/filters/EqualizerFilter.ts","../src/filters/DistortionFilter.ts","../src/filters/StereoFilter.ts","../src/filters/ReverbFilter.ts","../src/filters/MonoFilter.ts","../src/filters/TelephoneFilter.ts","../src/webaudio/index.ts","../src/utils/playOnce.ts","../src/utils/index.ts","../src/utils/render.ts","../src/utils/sineTone.ts","../src/index.ts","../src/browser.ts"],"sourcesContent":["import { SoundLibrary } from './SoundLibrary';\n\n/**\n * Singleton instance of the SoundLibrary\n */\nlet instance: SoundLibrary;\n\n/**\n * Internal set function for the singleton instance.\n * @ignore\n * @param sound - - Sound library instance\n */\nfunction setInstance(sound: SoundLibrary): SoundLibrary\n{\n    instance = sound;\n\n    return sound;\n}\n\n/**\n * Internal get function for the singleton instance.\n * @ignore\n */\nfunction getInstance(): SoundLibrary\n{\n    return instance;\n}\n\nexport { instance, setInstance, getInstance };\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","type ExtensionMap = {[key: string]: boolean};\n\n/**\n * The list of extensions that can be played.\n * @readonly\n * @static\n */\nconst extensions: string[] = [\n    'mp3',\n    'ogg',\n    'oga',\n    'opus',\n    'mpeg',\n    'wav',\n    'm4a',\n    'aiff',\n    'wma',\n    'mid',\n    'caf',\n];\n\n/**\n * The list of browser supported audio formats.\n * @readonly\n * @static\n * @property {boolean} mp3 - `true` if file-type is supported\n * @property {boolean} ogg - `true` if file-type is supported\n * @property {boolean} oga - `true` if file-type is supported\n * @property {boolean} opus - `true` if file-type is supported\n * @property {boolean} mpeg - `true` if file-type is supported\n * @property {boolean} wav - `true` if file-type is supported\n * @property {boolean} aiff - `true` if file-type is supported\n * @property {boolean} wma - `true` if file-type is supported\n * @property {boolean} mid - `true` if file-type is supported\n * @property {boolean} caf - `true` if file-type is supported. Note that for this we check if the\n *                             'opus' codec is supported inside the caf container.\n */\nconst supported: ExtensionMap = {};\n\n/**\n * Function to validate file type formats. This is called when the library initializes, but can\n * be called again if you need to recognize a format not listed in `utils.extensions` at\n * initialization.\n * @static\n * @param {object} typeOverrides - - Dictionary of type overrides (inputs for\n *                                 AudioElement.canPlayType()), keyed by extension from the\n *                                 utils.extensions array.\n */\nfunction validateFormats(typeOverrides?: {[key: string]: string}): void\n{\n    const overrides: {[key: string]: string} = {\n        m4a: 'audio/mp4',\n        oga: 'audio/ogg',\n        opus: 'audio/ogg; codecs=\"opus\"',\n        caf: 'audio/x-caf; codecs=\"opus\"', ...(typeOverrides || {}) };\n    const audio = document.createElement('audio');\n    const formats: ExtensionMap = {};\n    const no = /^no$/;\n\n    extensions.forEach((ext) =>\n    {\n        const canByExt = audio.canPlayType(`audio/${ext}`).replace(no, '');\n        const canByType = overrides[ext] ? audio.canPlayType(overrides[ext]).replace(no, '') : '';\n\n        formats[ext] = !!canByExt || !!canByType;\n    });\n    Object.assign(supported, formats);\n}\n\n// initialize supported\nvalidateFormats();\n\nexport {\n    validateFormats,\n    supported,\n    extensions\n};\n","import type { ILoaderResource } from '@pixi/loaders';\nimport { supported } from './supported';\n\n/**\n * RegExp for looking for format patterns.\n * @static\n */\nconst FORMAT_PATTERN = /\\.(\\{([^\\}]+)\\})(\\?.*)?$/;\n\n/**\n * Resolve a URL with different formats in glob pattern to\n * a path based on the supported browser format. For instance:\n * \"sounds/music.{ogg,mp3}\", would resolve to \"sounds/music.ogg\"\n * if \"ogg\" support is found, otherwise, fallback to \"sounds.music.mp3\"\n * @static\n * @param {string|PIXI.LoaderResource} source - - Path to resolve or Resource, if\n *        a Resource object is provided, automatically updates the extension and url\n *        of that object.\n * @return The format to resolve to\n */\nfunction resolveUrl(source: string | ILoaderResource): string\n{\n    // search for patterns like \".{mp3,ogg}\"\"\n    const glob = FORMAT_PATTERN;\n    const url: string = typeof source === 'string' ? source : source.url;\n\n    if (!glob.test(url))\n    {\n        return url;\n    }\n\n    const match = glob.exec(url);\n    const exts = match[2].split(',');\n    let replace = exts[exts.length - 1]; // fallback to last ext\n\n    for (let i = 0, len = exts.length; i < len; i++)\n    {\n        const ext = exts[i];\n\n        if (supported[ext])\n        {\n            replace = ext;\n            break;\n        }\n    }\n    const resolved = url.replace(match[1], replace);\n\n    if (!(typeof source === 'string'))\n    {\n        // resource-loader marks these as readonly\n        const writableSource = source as { extension: string, url: string };\n\n        writableSource.extension = replace;\n        writableSource.url = resolved;\n    }\n\n    return resolved;\n}\n\nexport { resolveUrl };\n","import { ILoaderPlugin, ILoaderResource, LoaderResource } from '@pixi/loaders';\nimport { getInstance } from './instance';\nimport { resolveUrl } from './utils/resolveUrl';\nimport { extensions } from './utils/supported';\n\n/**\n * Sound middleware installation utilities for PIXI.Loader\n * @class\n */\nclass SoundLoader implements ILoaderPlugin\n{\n    /** Install the middleware */\n    public static add(): void\n    {\n        SoundLoader.setLegacy(getInstance().useLegacy);\n    }\n\n    /**\n     * Set the legacy mode\n     * @param legacy - Non-webaudio environments\n     */\n    static setLegacy(legacy: boolean): void\n    {\n        // Configure PIXI Loader to handle audio files correctly\n        const exts = extensions;\n\n        // Make sure we support webaudio\n        if (!legacy)\n        {\n            // Load all audio files as ArrayBuffers\n            exts.forEach((ext) =>\n            {\n                LoaderResource.setExtensionXhrType(ext, LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\n                LoaderResource.setExtensionLoadType(ext, LoaderResource.LOAD_TYPE.XHR);\n            });\n        }\n        else\n        {\n            // Fall back to loading as <audio> elements\n            exts.forEach((ext) =>\n            {\n                LoaderResource.setExtensionXhrType(ext, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT);\n                LoaderResource.setExtensionLoadType(ext, LoaderResource.LOAD_TYPE.AUDIO);\n            });\n        }\n    }\n\n    /** Handle the preprocessing of file paths */\n    public static pre(resource: ILoaderResource, next: () => void): void\n    {\n        resolveUrl(resource);\n        next();\n    }\n\n    /** Actual resource-loader middleware for sound class */\n    public static use(resource: ILoaderResource, next: () => void): void\n    {\n        if (resource.data && extensions.indexOf(resource.extension) > -1)\n        {\n            (resource as any).sound = getInstance().add(resource.name, {\n                loaded: next,\n                preload: true,\n                url: resource.url,\n                source: resource.data,\n            });\n        }\n        else\n        {\n            next();\n        }\n    }\n}\n\nexport { SoundLoader };\n","import { Ticker } from '@pixi/ticker';\nimport { EventEmitter } from '@pixi/utils';\nimport { IMediaInstance } from '../interfaces/IMediaInstance';\nimport { PlayOptions } from '../Sound';\nimport { HTMLAudioMedia } from './HTMLAudioMedia';\n\nlet id = 0;\n\n/**\n * Instance which wraps the `<audio>` element playback.\n * @class\n * @memberof htmlaudio\n */\nclass HTMLAudioInstance extends EventEmitter implements IMediaInstance\n{\n    /** Extra padding, in seconds, to deal with low-latecy of HTMLAudio. */\n    public static readonly PADDING: number = 0.1;\n\n    /** The current unique ID for this instance. */\n    public readonly id: number;\n\n    /** The instance of the Audio element. */\n    private _source: HTMLAudioElement;\n\n    /** The instance of the Audio media element. */\n    private _media: HTMLAudioMedia;\n\n    /** Playback rate, where 1 is 100%. */\n    private _end: number;\n\n    /** Current instance paused state. */\n    private _paused: boolean;\n\n    /** Current instance muted state. */\n    private _muted: boolean;\n\n    /** Current actual paused state. */\n    private _pausedReal: boolean;\n\n    /** Total length of the audio. */\n    private _duration: number;\n\n    /** Playback rate, where 1 is 100%. */\n    private _start: number;\n\n    /** `true` if the audio is actually playing. */\n    private _playing: boolean;\n\n    /** Volume for the instance. */\n    private _volume: number;\n\n    /** Speed for the instance. */\n    private _speed: number;\n\n    /** `true` for looping the playback */\n    private _loop: boolean;\n\n    /** @param parent - Parent element */\n    constructor(parent: HTMLAudioMedia)\n    {\n        super();\n\n        this.id = id++;\n\n        this.init(parent);\n    }\n\n    /**\n     * Set a property by name, this makes it easy to chain values\n     * @param {string} name - - Values include: 'speed', 'volume', 'muted', 'loop', 'paused'\n     * @param {number|boolean} value - - Value to set property to\n     */\n    public set(name: 'speed' | 'volume' | 'muted' | 'loop' | 'paused', value: number | boolean): this\n    {\n        if (this[name] === undefined)\n        {\n            throw new Error(`Property with name ${name} does not exist.`);\n        }\n        else\n        {\n            switch (name)\n            {\n                case 'speed': this.speed = value as number; break;\n                case 'volume': this.volume = value as number; break;\n                case 'paused': this.paused = value as boolean; break;\n                case 'loop': this.loop = value as boolean; break;\n                case 'muted': this.muted = value as boolean; break;\n            }\n        }\n\n        return this;\n    }\n\n    /** The current playback progress from 0 to 1. */\n    public get progress(): number\n    {\n        const { currentTime } = this._source;\n\n        return currentTime / this._duration;\n    }\n\n    /** Pauses the sound. */\n    public get paused(): boolean\n    {\n        return this._paused;\n    }\n    public set paused(paused: boolean)\n    {\n        this._paused = paused;\n        this.refreshPaused();\n    }\n\n    /**\n     * Reference: http://stackoverflow.com/a/40370077\n     * @private\n     */\n    private _onPlay(): void\n    {\n        this._playing = true;\n    }\n\n    /**\n     * Reference: http://stackoverflow.com/a/40370077\n     * @private\n     */\n    private _onPause(): void\n    {\n        this._playing = false;\n    }\n\n    /**\n     * Initialize the instance.\n     * @param {htmlaudio.HTMLAudioMedia} media - Same as constructor\n     */\n    public init(media: HTMLAudioMedia): void\n    {\n        this._playing = false;\n        this._duration = media.source.duration;\n        const source = this._source = media.source.cloneNode(false) as HTMLAudioElement;\n\n        source.src = media.parent.url;\n        source.onplay = this._onPlay.bind(this);\n        source.onpause = this._onPause.bind(this);\n        media.context.on('refresh', this.refresh, this);\n        media.context.on('refreshPaused', this.refreshPaused, this);\n        this._media = media;\n    }\n\n    /**\n     * Stop the sound playing\n     * @private\n     */\n    private _internalStop(): void\n    {\n        if (this._source && this._playing)\n        {\n            this._source.onended = null;\n            this._source.pause();\n        }\n    }\n\n    /** Stop the sound playing */\n    public stop(): void\n    {\n        this._internalStop();\n\n        if (this._source)\n        {\n            this.emit('stop');\n        }\n    }\n\n    /** Set the instance speed from 0 to 1 */\n    public get speed(): number\n    {\n        return this._speed;\n    }\n    public set speed(speed: number)\n    {\n        this._speed = speed;\n        this.refresh();\n    }\n\n    /**\n     * Get the set the volume for this instance from 0 to 1\n     * @type {number}\n     */\n    public get volume(): number\n    {\n        return this._volume;\n    }\n    public set volume(volume: number)\n    {\n        this._volume = volume;\n        this.refresh();\n    }\n\n    /**\n     * If the sound instance should loop playback\n     * @type {number}\n     */\n    public get loop(): boolean\n    {\n        return this._loop;\n    }\n    public set loop(loop: boolean)\n    {\n        this._loop = loop;\n        this.refresh();\n    }\n\n    /**\n     * `true` if the sound is muted\n     * @type {boolean}\n     */\n    public get muted(): boolean\n    {\n        return this._muted;\n    }\n    public set muted(muted: boolean)\n    {\n        this._muted = muted;\n        this.refresh();\n    }\n\n    /** Call whenever the loop, speed or volume changes */\n    public refresh(): void\n    {\n        const global = this._media.context;\n        const sound = this._media.parent;\n\n        // Update the looping\n        this._source.loop = this._loop || sound.loop;\n\n        // Update the volume\n        const globalVolume = global.volume * (global.muted ? 0 : 1);\n        const soundVolume = sound.volume * (sound.muted ? 0 : 1);\n        const instanceVolume = this._volume * (this._muted ? 0 : 1);\n\n        this._source.volume = instanceVolume * globalVolume * soundVolume;\n\n        // Update the speed\n        this._source.playbackRate = this._speed * global.speed * sound.speed;\n    }\n\n    /** Handle changes in paused state, either globally or sound or instance */\n    public refreshPaused(): void\n    {\n        const global = this._media.context;\n        const sound = this._media.parent;\n\n        // Handle the paused state\n        const pausedReal = this._paused || sound.paused || global.paused;\n\n        if (pausedReal !== this._pausedReal)\n        {\n            this._pausedReal = pausedReal;\n\n            if (pausedReal)\n            {\n                this._internalStop();\n\n                /**\n                 * The sound is paused.\n                 * @event paused\n                 */\n                this.emit('paused');\n            }\n            else\n            {\n                /**\n                 * The sound is unpaused.\n                 * @event resumed\n                 */\n                this.emit('resumed');\n\n                // resume the playing with offset\n                this.play({\n                    start: this._source.currentTime,\n                    end: this._end,\n                    volume: this._volume,\n                    speed: this._speed,\n                    loop: this._loop,\n                });\n            }\n\n            /**\n             * The sound is paused or unpaused.\n             * @event pause\n             * @property {boolean} paused - If the instance was paused or not.\n             */\n            this.emit('pause', pausedReal);\n        }\n    }\n\n    /** Start playing the sound/ */\n    public play(options: PlayOptions): void\n    {\n        const { start, end, speed, loop, volume, muted } = options;\n\n        if (end)\n        {\n            // eslint-disable-next-line no-console\n            console.assert(end > start, 'End time is before start time');\n        }\n\n        this._speed = speed;\n        this._volume = volume;\n        this._loop = !!loop;\n        this._muted = muted;\n        this.refresh();\n\n        // WebAudio doesn't support looping when a duration is set\n        // we'll set this just for the heck of it\n        if (this.loop && end !== null)\n        {\n            console.warn('Looping not support when specifying an \"end\" time');\n            this.loop = false;\n        }\n\n        this._start = start;\n        this._end = end || this._duration;\n\n        // Lets expand the start and end a little\n        // to deal with the low-latecy of playing audio this way\n        // this is a little fudge-factor\n        this._start = Math.max(0, this._start - HTMLAudioInstance.PADDING);\n        this._end = Math.min(this._end + HTMLAudioInstance.PADDING, this._duration);\n\n        this._source.onloadedmetadata = () =>\n        {\n            if (this._source)\n            {\n                this._source.currentTime = start;\n                this._source.onloadedmetadata = null;\n                this.emit('progress', start, this._duration);\n                Ticker.shared.add(this._onUpdate, this);\n            }\n        };\n        this._source.onended = this._onComplete.bind(this);\n        this._source.play();\n\n        /**\n         * The sound is started.\n         * @event start\n         */\n        this.emit('start');\n    }\n\n    /**\n     * Handle time update on sound.\n     * @private\n     */\n    private _onUpdate(): void\n    {\n        this.emit('progress', this.progress, this._duration);\n        if (this._source.currentTime >= this._end && !this._source.loop)\n        {\n            this._onComplete();\n        }\n    }\n\n    /**\n     * Callback when completed.\n     * @private\n     */\n    private _onComplete(): void\n    {\n        Ticker.shared.remove(this._onUpdate, this);\n        this._internalStop();\n        this.emit('progress', 1, this._duration);\n        /**\n         * The sound ends, don't use after this\n         * @event end\n         */\n        this.emit('end', this);\n    }\n\n    /** Don't use after this. */\n    public destroy(): void\n    {\n        Ticker.shared.remove(this._onUpdate, this);\n        this.removeAllListeners();\n\n        const source = this._source;\n\n        if (source)\n        {\n            // Remove the listeners\n            source.onended = null;\n            source.onplay = null;\n            source.onpause = null;\n\n            this._internalStop();\n        }\n\n        this._source = null;\n        this._speed = 1;\n        this._volume = 1;\n        this._loop = false;\n        this._end = null;\n        this._start = 0;\n        this._duration = 0;\n        this._playing = false;\n        this._pausedReal = false;\n        this._paused = false;\n        this._muted = false;\n\n        if (this._media)\n        {\n            this._media.context.off('refresh', this.refresh, this);\n            this._media.context.off('refreshPaused', this.refreshPaused, this);\n            this._media = null;\n        }\n    }\n\n    /**\n     * To string method for instance.\n     * @return The string representation of instance.\n     */\n    public toString(): string\n    {\n        return `[HTMLAudioInstance id=${this.id}]`;\n    }\n}\n\nexport { HTMLAudioInstance };\n","import { EventEmitter } from '@pixi/utils';\nimport { Filter } from '../filters/Filter';\nimport { IMedia } from '../interfaces/IMedia';\nimport { LoadedCallback, Sound } from '../Sound';\nimport { HTMLAudioContext } from './HTMLAudioContext';\nimport { HTMLAudioInstance } from './HTMLAudioInstance';\n\n/**\n * The fallback version of Sound which uses `<audio>` instead of WebAudio API.\n * @class\n * @memberof htmlaudio\n * @param {HTMLAudioElement|String|Object} options - Either the path or url to the source file.\n *        or the object of options to use. See {@link Sound.from}\n */\nclass HTMLAudioMedia extends EventEmitter implements IMedia\n{\n    public parent: Sound;\n    private _source: HTMLAudioElement;\n\n    public init(parent: Sound): void\n    {\n        this.parent = parent;\n        this._source = parent.options.source as HTMLAudioElement || new Audio();\n        if (parent.url)\n        {\n            this._source.src = parent.url;\n        }\n    }\n\n    // Implement create\n    public create(): HTMLAudioInstance\n    {\n        return new HTMLAudioInstance(this);\n    }\n\n    /**\n     * @type {boolean}\n     * @readonly\n     */\n    public get isPlayable(): boolean\n    {\n        return !!this._source && this._source.readyState === 4;\n    }\n\n    /**\n     * @type {number}\n     * @readonly\n     */\n    public get duration(): number\n    {\n        return this._source.duration;\n    }\n\n    /**\n     * @type {HTMLAudioContext}\n     * @readonly\n     */\n    public get context(): HTMLAudioContext\n    {\n        return this.parent.context as HTMLAudioContext;\n    }\n\n    /**\n     * @type {Array<Filter>}\n     */\n    public get filters(): Filter[]\n    {\n        return null;\n    }\n    public set filters(_filters: Filter[])\n    {\n        console.warn('HTML Audio does not support filters');\n    }\n\n    // Override the destroy\n    public destroy(): void\n    {\n        this.removeAllListeners();\n\n        this.parent = null;\n\n        if (this._source)\n        {\n            this._source.src = '';\n            this._source.load();\n            this._source = null;\n        }\n    }\n\n    /**\n     * Get the audio source element.\n     * @type {HTMLAudioElement}\n     * @readonly\n     */\n    public get source(): HTMLAudioElement\n    {\n        return this._source;\n    }\n\n    // Implement the method to being preloading\n    public load(callback?: LoadedCallback): void\n    {\n        const source = this._source;\n        const sound = this.parent;\n\n        // See if the source is already loaded\n        if (source.readyState === 4)\n        {\n            sound.isLoaded = true;\n            const instance = sound.autoPlayStart();\n\n            if (callback)\n            {\n                setTimeout(() =>\n                {\n                    callback(null, sound, instance);\n                }, 0);\n            }\n\n            return;\n        }\n\n        // If there's no source, we cannot load\n        if (!sound.url)\n        {\n            callback(new Error('sound.url or sound.source must be set'));\n\n            return;\n        }\n\n        // Set the source\n        source.src = sound.url;\n\n        const onLoad = () =>\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            removeListeners();\n            sound.isLoaded = true;\n            const instance = sound.autoPlayStart();\n\n            if (callback)\n            {\n                callback(null, sound, instance);\n            }\n        };\n\n        const onAbort = () =>\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            removeListeners();\n            if (callback)\n            {\n                callback(new Error('Sound loading has been aborted'));\n            }\n        };\n\n        const onError = () =>\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            removeListeners();\n            const message = `Failed to load audio element (code: ${source.error.code})`;\n\n            if (callback)\n            {\n                callback(new Error(message));\n            }\n            else\n            {\n                console.error(message);\n            }\n        };\n\n        // Remove all event listeners\n        const removeListeners = () =>\n        {\n            // Listen for callback\n            source.removeEventListener('canplaythrough', onLoad);\n            source.removeEventListener('load', onLoad);\n            source.removeEventListener('abort', onAbort);\n            source.removeEventListener('error', onError);\n        };\n\n        // Listen for callback\n        source.addEventListener('canplaythrough', onLoad, false);\n        source.addEventListener('load', onLoad, false);\n        source.addEventListener('abort', onAbort, false);\n        source.addEventListener('error', onError, false);\n\n        // Begin the loading\n        source.load();\n    }\n}\n\nexport { HTMLAudioMedia };\n","import { IMediaInstance } from './interfaces';\nimport { CompleteCallback, Sound } from './Sound';\n\n/**\n * Data for adding new sound sprites.\n */\ninterface SoundSpriteData {\n    /**\n     * The start time in seconds.\n     * @type {number}\n     */\n    start: number;\n    /**\n     * The end time in seconds.\n     * @type {number}\n     */\n    end: number;\n    /**\n     * The optional speed, if not speed, uses the default speed of the parent.\n     * @type {number}\n     */\n    speed?: number;\n}\n\n// Collection of sound sprites\ntype SoundSprites = {[id: string]: SoundSprite};\n\n/**\n * Object that represents a single Sound's sprite. To add sound sprites\n * use the {@link Sound#addSprites} method.\n * @class\n * @example\n * import { sound } from '@pixi/sound';\n * sound.add('alias', {\n *   url: 'path/to/file.ogg',\n *   sprites: {\n *     blast: { start: 0, end: 0.2 },\n *     boom: { start: 0.3, end: 0.5 },\n *   },\n *   loaded() {\n *     sound.play('alias', 'blast');\n *   }\n * );\n *\n */\nclass SoundSprite\n{\n    /**\n     * The reference sound\n     * @readonly\n     */\n    public parent: Sound;\n\n    /**\n     * The starting location in seconds.\n     * @readonly\n     */\n    public start: number;\n\n    /**\n     * The ending location in seconds\n     * @readonly\n     */\n    public end: number;\n\n    /**\n     * The speed override where 1 is 100% speed playback.\n     * @readonly\n     */\n    public speed: number;\n\n    /**\n     * The duration of the sound in seconds.\n     * @readonly\n     */\n    public duration: number;\n\n    /**\n     * Whether to loop the sound sprite.\n     * @readonly\n     */\n    public loop: boolean;\n\n    /**\n     * @param parent - The parent sound\n     * @param options - Data associated with object.\n     */\n    constructor(parent: Sound, options: SoundSpriteData)\n    {\n        this.parent = parent;\n        Object.assign(this, options);\n        this.duration = this.end - this.start;\n\n        // eslint-disable-next-line no-console\n        console.assert(this.duration > 0, 'End time must be after start time');\n    }\n\n    /**\n     * Play the sound sprite.\n     * @param {Function} [complete] - Function call when complete\n     * @return Sound instance being played.\n     */\n    public play(complete?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>\n    {\n        return this.parent.play({\n            complete,\n            speed: this.speed || this.parent.speed,\n            end: this.end,\n            start: this.start,\n            loop: this.loop });\n    }\n\n    /** Destroy and don't use after this */\n    public destroy(): void\n    {\n        this.parent = null;\n    }\n}\n\nexport type { SoundSprites, SoundSpriteData };\nexport { SoundSprite };\n","import { getInstance } from '../instance';\nimport { WebAudioContext } from './WebAudioContext';\n\n/**\n * Internal class for Web Audio abstractions and convenience methods.\n * @class\n * @memberof webaudio\n */\nclass WebAudioUtils\n{\n    /**\n     * Dezippering is removed in the future Web Audio API, instead\n     * we use the `setValueAtTime` method, however, this is not available\n     * in all environments (e.g., Android webview), so we fallback to the `value` setter.\n     * @param param - AudioNode parameter object\n     * @param value - Value to set\n     * @return The value set\n     */\n    public static setParamValue(param: AudioParam, value: number): number\n    {\n        if (param.setValueAtTime)\n        {\n            const context = getInstance().context as WebAudioContext;\n\n            param.setValueAtTime(value, context.audioContext.currentTime);\n        }\n        else\n        {\n            param.value = value;\n        }\n\n        return value;\n    }\n}\n\nexport { WebAudioUtils };\n","import { Ticker } from '@pixi/ticker';\nimport { EventEmitter } from '@pixi/utils';\nimport { IMediaInstance } from '../interfaces';\nimport { PlayOptions } from '../Sound';\nimport { WebAudioMedia } from './WebAudioMedia';\nimport { WebAudioUtils } from './WebAudioUtils';\n\nlet id = 0;\n\n/**\n * A single play instance that handles the AudioBufferSourceNode.\n * @class\n * @memberof webaudio\n * @param {SoundNodes} source - Reference to the SoundNodes.\n */\nclass WebAudioInstance extends EventEmitter implements IMediaInstance\n{\n    /**\n     * The current unique ID for this instance.\n     * @readonly\n     */\n    public readonly id: number;\n\n    /**\n     * The source Sound.\n     * @type {webaudio.WebAudioMedia}\n     */\n    private _media: WebAudioMedia;\n\n    /**\n     * true if paused.\n     * @type {boolean}\n     */\n    private _paused: boolean;\n\n    /**\n     * true if muted.\n     * @type {boolean}\n     */\n    private _muted: boolean;\n\n    /**\n     * true if paused.\n     * @type {boolean}\n     */\n    private _pausedReal: boolean;\n\n    /**\n     * The instance volume\n     * @type {number}\n     */\n    private _volume: number;\n\n    /**\n     * Last update frame number.\n     * @type {number}\n     */\n    private _lastUpdate: number;\n\n    /**\n     * The total number of seconds elapsed in playback.\n     * @type {number}\n     */\n    private _elapsed: number;\n\n    /**\n     * Playback rate, where 1 is 100%.\n     * @type {number}\n     */\n    private _speed: number;\n\n    /**\n     * Playback rate, where 1 is 100%.\n     * @type {number}\n     */\n    private _end: number;\n\n    /**\n     * `true` if should be looping.\n     * @type {boolean}\n     */\n    private _loop: boolean;\n\n    /**\n     * Gain node for controlling volume of instance\n     * @type {GainNode}\n     */\n    private _gain: GainNode;\n\n    /**\n     * Length of the sound in seconds.\n     * @type {number}\n     */\n    private _duration: number;\n\n    /**\n     * The progress of the sound from 0 to 1.\n     * @type {number}\n     */\n    private _progress: number;\n\n    /**\n     * Audio buffer source clone from Sound object.\n     * @type {AudioBufferSourceNode}\n     */\n    private _source: AudioBufferSourceNode;\n\n    constructor(media: WebAudioMedia)\n    {\n        super();\n\n        this.id = id++;\n        this._media = null;\n        this._paused = false;\n        this._muted = false;\n        this._elapsed = 0;\n\n        // Initialize\n        this.init(media);\n    }\n\n    /**\n     * Set a property by name, this makes it easy to chain values\n     * @param {string} name - - Values include: 'speed', 'volume', 'muted', 'loop', 'paused'\n     * @param {number|boolean} value - - Value to set property to\n     */\n    public set(name: 'speed' | 'volume' | 'muted' | 'loop' | 'paused', value: number | boolean): this\n    {\n        if (this[name] === undefined)\n        {\n            throw new Error(`Property with name ${name} does not exist.`);\n        }\n        else\n        {\n            switch (name)\n            {\n                case 'speed': this.speed = value as number; break;\n                case 'volume': this.volume = value as number; break;\n                case 'muted': this.muted = value as boolean; break;\n                case 'loop': this.loop = value as boolean; break;\n                case 'paused': this.paused = value as boolean; break;\n            }\n        }\n\n        return this;\n    }\n\n    /** Stops the instance, don't use after this. */\n    public stop(): void\n    {\n        if (this._source)\n        {\n            this._internalStop();\n            this.emit('stop');\n        }\n    }\n\n    /** Set the instance speed from 0 to 1 */\n    public get speed(): number\n    {\n        return this._speed;\n    }\n    public set speed(speed: number)\n    {\n        this._speed = speed;\n        this.refresh();\n        this._update(true); // update progress\n    }\n\n    /** Get the set the volume for this instance from 0 to 1 */\n    public get volume(): number\n    {\n        return this._volume;\n    }\n    public set volume(volume: number)\n    {\n        this._volume = volume;\n        this.refresh();\n    }\n\n    /** `true` if the sound is muted */\n    public get muted(): boolean\n    {\n        return this._muted;\n    }\n    public set muted(muted: boolean)\n    {\n        this._muted = muted;\n        this.refresh();\n    }\n\n    /** If the sound instance should loop playback */\n    public get loop(): boolean\n    {\n        return this._loop;\n    }\n    public set loop(loop: boolean)\n    {\n        this._loop = loop;\n        this.refresh();\n    }\n\n    /** Refresh loop, volume and speed based on changes to parent */\n    public refresh(): void\n    {\n        // Sound could be paused\n        if (!this._source)\n        {\n            return;\n        }\n        const global = this._media.context;\n        const sound = this._media.parent;\n\n        // Updating looping\n        this._source.loop = this._loop || sound.loop;\n\n        // Update the volume\n        const globalVolume = global.volume * (global.muted ? 0 : 1);\n        const soundVolume = sound.volume * (sound.muted ? 0 : 1);\n        const instanceVolume = this._volume * (this._muted ? 0 : 1);\n\n        WebAudioUtils.setParamValue(this._gain.gain, instanceVolume * soundVolume * globalVolume);\n\n        // Update the speed\n        WebAudioUtils.setParamValue(this._source.playbackRate, this._speed * sound.speed * global.speed);\n    }\n\n    /** Handle changes in paused state, either globally or sound or instance */\n    public refreshPaused(): void\n    {\n        const global = this._media.context;\n        const sound = this._media.parent;\n\n        // Consider global and sound paused\n        const pausedReal = this._paused || sound.paused || global.paused;\n\n        if (pausedReal !== this._pausedReal)\n        {\n            this._pausedReal = pausedReal;\n\n            if (pausedReal)\n            {\n                // pause the sounds\n                this._internalStop();\n\n                /**\n                 * The sound is paused.\n                 * @event paused\n                 */\n                this.emit('paused');\n            }\n            else\n            {\n                /**\n                 * The sound is unpaused.\n                 * @event resumed\n                 */\n                this.emit('resumed');\n\n                // resume the playing with offset\n                this.play({\n                    start: this._elapsed % this._duration,\n                    end: this._end,\n                    speed: this._speed,\n                    loop: this._loop,\n                    volume: this._volume,\n                });\n            }\n\n            /**\n             * The sound is paused or unpaused.\n             * @event pause\n             * @property {boolean} paused - If the instance was paused or not.\n             */\n            this.emit('pause', pausedReal);\n        }\n    }\n\n    /**\n     * Plays the sound.\n     * @param {Object} options - Play options\n     * @param {number} options.start - The position to start playing, in seconds.\n     * @param {number} options.end - The ending position in seconds.\n     * @param {number} options.speed - Speed for the instance\n     * @param {boolean} options.loop - If the instance is looping, defaults to sound loop\n     * @param {number} options.volume - Volume of the instance\n     * @param {boolean} options.muted - Muted state of instance\n     */\n    public play(options: PlayOptions): void\n    {\n        const { start, end, speed, loop, volume, muted } = options;\n\n        if (end)\n        {\n            // eslint-disable-next-line no-console\n            console.assert(end > start, 'End time is before start time');\n        }\n        this._paused = false;\n        const { source, gain } = this._media.nodes.cloneBufferSource();\n\n        this._source = source;\n        this._gain = gain;\n        this._speed = speed;\n        this._volume = volume;\n        this._loop = !!loop;\n        this._muted = muted;\n        this.refresh();\n\n        const duration: number = this._source.buffer.duration;\n\n        this._duration = duration;\n        this._end = end;\n        this._lastUpdate = this._now();\n        this._elapsed = start;\n        this._source.onended = this._onComplete.bind(this);\n\n        if (this._loop)\n        {\n            this._source.loopEnd = end;\n            this._source.loopStart = start;\n            this._source.start(0, start);\n        }\n        else if (end)\n        {\n            this._source.start(0, start, end - start);\n        }\n        else\n        {\n            this._source.start(0, start);\n        }\n\n        /**\n         * The sound is started.\n         * @event start\n         */\n        this.emit('start');\n\n        // Do an update for the initial progress\n        this._update(true);\n\n        // Start handling internal ticks\n        this.enableTicker(true);\n    }\n\n    /**\n     * Start the update progress.\n     * @type {boolean}\n     */\n    private enableTicker(enabled: boolean): void\n    {\n        Ticker.shared.remove(this._updateListener, this);\n        if (enabled)\n        {\n            Ticker.shared.add(this._updateListener, this);\n        }\n    }\n\n    /**\n     * The current playback progress from 0 to 1.\n     * @type {number}\n     */\n    public get progress(): number\n    {\n        return this._progress;\n    }\n\n    /**\n     * Pauses the sound.\n     * @type {boolean}\n     */\n    public get paused(): boolean\n    {\n        return this._paused;\n    }\n\n    public set paused(paused: boolean)\n    {\n        this._paused = paused;\n        this.refreshPaused();\n    }\n\n    /** Don't use after this. */\n    public destroy(): void\n    {\n        this.removeAllListeners();\n        this._internalStop();\n        if (this._gain)\n        {\n            this._gain.disconnect();\n            this._gain = null;\n        }\n        if (this._media)\n        {\n            this._media.context.events.off('refresh', this.refresh, this);\n            this._media.context.events.off('refreshPaused', this.refreshPaused, this);\n            this._media = null;\n        }\n        this._end = null;\n        this._speed = 1;\n        this._volume = 1;\n        this._loop = false;\n        this._elapsed = 0;\n        this._duration = 0;\n        this._paused = false;\n        this._muted = false;\n        this._pausedReal = false;\n    }\n\n    /**\n     * To string method for instance.\n     * @return The string representation of instance.\n     */\n    public toString(): string\n    {\n        return `[WebAudioInstance id=${this.id}]`;\n    }\n\n    /**\n     * Get the current time in seconds.\n     * @return Seconds since start of context\n     */\n    private _now(): number\n    {\n        return this._media.context.audioContext.currentTime;\n    }\n\n    /**\n     * Callback for update listener\n     * @type {Function}\n     */\n    private _updateListener()\n    {\n        this._update();\n    }\n\n    /** Internal update the progress. */\n    private _update(force = false): void\n    {\n        if (this._source)\n        {\n            const now: number = this._now();\n            const delta: number = now - this._lastUpdate;\n\n            if (delta > 0 || force)\n            {\n                const speed: number = this._source.playbackRate.value;\n\n                this._elapsed += delta * speed;\n                this._lastUpdate = now;\n                const duration: number = this._duration;\n                let progress: number;\n\n                if (this._source.loopStart)\n                {\n                    const soundLength = this._source.loopEnd - this._source.loopStart;\n\n                    progress = (this._source.loopStart + (this._elapsed % soundLength)) / duration;\n                }\n                else\n                {\n                    progress = (this._elapsed % duration) / duration;\n                }\n\n                // Update the progress\n                this._progress = progress;\n\n                /**\n                 * The sound progress is updated.\n                 * @event progress\n                 * @property {number} progress - Amount progressed from 0 to 1\n                 * @property {number} duration - The total playback in seconds\n                 */\n                this.emit('progress', this._progress, duration);\n            }\n        }\n    }\n\n    /** Initializes the instance. */\n    public init(media: WebAudioMedia): void\n    {\n        this._media = media;\n        media.context.events.on('refresh', this.refresh, this);\n        media.context.events.on('refreshPaused', this.refreshPaused, this);\n    }\n\n    /** Stops the instance. */\n    private _internalStop(): void\n    {\n        if (this._source)\n        {\n            this.enableTicker(false);\n            this._source.onended = null;\n            this._source.stop(0); // param needed for iOS 8 bug\n            this._source.disconnect();\n            try\n            {\n                this._source.buffer = null;\n            }\n            catch (err)\n            {\n                // try/catch workaround for bug in older Chrome versions\n                console.warn('Failed to set AudioBufferSourceNode.buffer to null:', err);\n            }\n            this._source = null;\n        }\n    }\n\n    /** Callback when completed. */\n    private _onComplete(): void\n    {\n        if (this._source)\n        {\n            this.enableTicker(false);\n            this._source.onended = null;\n            this._source.disconnect();\n            try\n            {\n                this._source.buffer = null;\n            }\n            catch (err)\n            {\n                // try/catch workaround for bug in older Chrome versions\n                console.warn('Failed to set AudioBufferSourceNode.buffer to null:', err);\n            }\n        }\n        this._source = null;\n        this._progress = 1;\n        this.emit('progress', 1, this._duration);\n        /**\n         * The sound ends, don't use after this\n         * @event end\n         */\n        this.emit('end', this);\n    }\n}\n\nexport { WebAudioInstance };\n","import { Filter } from './filters/Filter';\n\n/**\n * Abstract class which SoundNodes and SoundContext\n * both extend. This provides the functionality for adding\n * dynamic filters.\n * @class\n */\nclass Filterable\n{\n    /** Get the gain node */\n    private _input: AudioNode;\n\n    /** The destination output audio node */\n    private _output: AudioNode;\n\n    /**\n     * Collection of filters.\n     * @type {filters.Filter[]}\n     */\n    private _filters: Filter[];\n\n    /**\n     * @param {AudioNode} source - The source audio node\n     * @param {AudioNode} destination - The output audio node\n     */\n    constructor(input: AudioNode, output: AudioNode)\n    {\n        this._output = output;\n        this._input = input;\n    }\n\n    /** The destination output audio node */\n    get destination(): AudioNode\n    {\n        return this._input;\n    }\n\n    /**\n     * The collection of filters\n     * @type {filters.Filter[]}\n     */\n    get filters(): Filter[]\n    {\n        return this._filters;\n    }\n    set filters(filters: Filter[])\n    {\n        if (this._filters)\n        {\n            this._filters.forEach((filter: Filter) =>\n            {\n                if (filter)\n                {\n                    filter.disconnect();\n                }\n            });\n            this._filters = null;\n            // Reconnect direct path\n            this._input.connect(this._output);\n        }\n\n        if (filters && filters.length)\n        {\n            this._filters = filters.slice(0);\n\n            // Disconnect direct path before inserting filters\n            this._input.disconnect();\n\n            // Connect each filter\n            let prevFilter: Filter = null;\n\n            filters.forEach((filter: Filter) =>\n            {\n                if (prevFilter === null)\n                {\n                    // first filter is the destination\n                    // for the analyser\n                    this._input.connect(filter.destination);\n                }\n                else\n                {\n                    prevFilter.connect(filter.destination);\n                }\n                prevFilter = filter;\n            });\n            prevFilter.connect(this._output);\n        }\n    }\n\n    /** Cleans up. */\n    public destroy(): void\n    {\n        this.filters = null;\n        this._input = null;\n        this._output = null;\n    }\n}\n\nexport { Filterable };\n","import { Filterable } from '../Filterable';\nimport { WebAudioContext } from './WebAudioContext';\nimport { WebAudioUtils } from './WebAudioUtils';\n\n/**\n * Output for cloning source node.\n */\ninterface SourceClone {\n    /**\n     * Cloned audio buffer source\n     * @type {AudioBufferSourceNode}\n     */\n    source: AudioBufferSourceNode;\n    /**\n     * Independent volume control\n     * @type {GainNode}\n     */\n    gain: GainNode;\n}\n\n/**\n * @class\n * @memberof webaudio\n */\nclass WebAudioNodes extends Filterable\n{\n    /**\n     * The buffer size for script processor, default is `0` which auto-detects. If you plan to use\n     * script node on iOS, you'll need to provide a non-zero amount.\n     * @type {number}\n     * @default 0\n     */\n    public static BUFFER_SIZE = 0;\n\n    /**\n     * Get the buffer source node\n     * @type {AudioBufferSourceNode}\n     * @readonly\n     */\n    public bufferSource: AudioBufferSourceNode;\n\n    /**\n     * Get the gain node\n     * @type {GainNode}\n     * @readonly\n     */\n    public gain: GainNode;\n\n    /**\n     * Get the analyser node\n     * @type {AnalyserNode}\n     * @readonly\n     */\n    public analyser: AnalyserNode;\n\n    /**\n     * Reference to the SoundContext\n     * @type {webaudio.WebAudioContext}\n     * @readonly\n     */\n    public context: WebAudioContext;\n\n    /**\n     * Private reference to the script processor node.\n     * @type {ScriptProcessorNode}\n     */\n    private _script: ScriptProcessorNode;\n\n    /**\n     * @param {webaudio.WebAudioContext} audioContext - The audio context.\n     */\n    constructor(context: WebAudioContext)\n    {\n        const audioContext: AudioContext = context.audioContext;\n\n        const bufferSource: AudioBufferSourceNode = audioContext.createBufferSource();\n        const gain: GainNode = audioContext.createGain();\n        const analyser: AnalyserNode = audioContext.createAnalyser();\n\n        bufferSource.connect(analyser);\n        analyser.connect(gain);\n        gain.connect(context.destination);\n\n        super(analyser, gain);\n\n        this.context = context;\n        this.bufferSource = bufferSource;\n        this.gain = gain;\n        this.analyser = analyser;\n    }\n\n    /**\n     * Get the script processor node.\n     * @readonly\n     * @type {ScriptProcessorNode}\n     */\n    public get script(): ScriptProcessorNode\n    {\n        if (!this._script)\n        {\n            this._script = this.context.audioContext.createScriptProcessor(WebAudioNodes.BUFFER_SIZE);\n            this._script.connect(this.context.destination);\n        }\n\n        return this._script;\n    }\n\n    /** Cleans up. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        this.bufferSource.disconnect();\n        if (this._script)\n        {\n            this._script.disconnect();\n        }\n        this.gain.disconnect();\n        this.analyser.disconnect();\n\n        this.bufferSource = null;\n        this._script = null;\n        this.gain = null;\n        this.analyser = null;\n\n        this.context = null;\n    }\n\n    /**\n     * Clones the bufferSource. Used just before playing a sound.\n     * @returns {SourceClone} The clone AudioBufferSourceNode.\n     */\n    public cloneBufferSource(): SourceClone\n    {\n        const orig: AudioBufferSourceNode = this.bufferSource;\n        const source: AudioBufferSourceNode = this.context.audioContext.createBufferSource();\n\n        source.buffer = orig.buffer;\n        WebAudioUtils.setParamValue(source.playbackRate, orig.playbackRate.value);\n        source.loop = orig.loop;\n\n        const gain: GainNode = this.context.audioContext.createGain();\n\n        source.connect(gain);\n        gain.connect(this.destination);\n\n        return { source, gain };\n    }\n\n    /**\n     * Get buffer size of `ScriptProcessorNode`.\n     * @readonly\n     * @type {number}\n     */\n    get bufferSize(): number\n    {\n        return this.script.bufferSize;\n    }\n}\n\nexport type { SourceClone };\nexport { WebAudioNodes };\n","import { Filter } from '../filters/Filter';\nimport { IMedia } from '../interfaces/IMedia';\nimport { LoadedCallback, Sound } from '../Sound';\nimport { WebAudioContext } from './WebAudioContext';\nimport { WebAudioInstance } from './WebAudioInstance';\nimport { WebAudioNodes } from './WebAudioNodes';\n\n/**\n * Represents a single sound element. Can be used to play, pause, etc. sound instances.\n * @class\n * @memberof webaudio\n */\nclass WebAudioMedia implements IMedia\n{\n    /**\n     * Reference to the parent Sound container.\n     * @type {Sound}\n     * @readonly\n     */\n    public parent: Sound;\n\n    /**\n     * The file buffer to load.\n     * @readonly\n     */\n    public source: ArrayBuffer;\n\n    /**\n     * Instance of the chain builder.\n     * @type {webaudio.WebAudioNodes}\n     */\n    private _nodes: WebAudioNodes;\n\n    /** Instance of the source node. */\n    private _source: AudioBufferSourceNode;\n\n    /**\n     * Re-initialize without constructing.\n     * @param {Sound} parent - - Instance of parent Sound container\n     */\n    public init(parent: Sound): void\n    {\n        this.parent = parent;\n        this._nodes = new WebAudioNodes(this.context);\n        this._source = this._nodes.bufferSource;\n        this.source = parent.options.source as ArrayBuffer;\n    }\n\n    /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */\n    public destroy(): void\n    {\n        this.parent = null;\n        this._nodes.destroy();\n        this._nodes = null;\n        try\n        {\n            this._source.buffer = null;\n        }\n        catch (err)\n        {\n            // try/catch workaround for bug in older Chrome versions\n            console.warn('Failed to set AudioBufferSourceNode.buffer to null:', err);\n        }\n        this._source = null;\n        this.source = null;\n    }\n\n    // Implement create\n    public create(): WebAudioInstance\n    {\n        return new WebAudioInstance(this);\n    }\n\n    // Implement context\n    public get context(): WebAudioContext\n    {\n        return this.parent.context as WebAudioContext;\n    }\n\n    // Implement isPlayable\n    public get isPlayable(): boolean\n    {\n        return !!this._source && !!this._source.buffer;\n    }\n\n    // Implement filters\n    public get filters(): Filter[]\n    {\n        return this._nodes.filters;\n    }\n    public set filters(filters: Filter[])\n    {\n        this._nodes.filters = filters;\n    }\n\n    // Implements duration\n    public get duration(): number\n    {\n        // eslint-disable-next-line no-console\n        console.assert(this.isPlayable, 'Sound not yet playable, no duration');\n\n        return this._source.buffer.duration;\n    }\n\n    /** Gets and sets the buffer. */\n    public get buffer(): AudioBuffer\n    {\n        return this._source.buffer;\n    }\n    public set buffer(buffer: AudioBuffer)\n    {\n        this._source.buffer = buffer;\n    }\n\n    /**\n     * Get the current chained nodes object\n     * @type {webaudio.WebAudioNodes}\n     */\n    public get nodes(): WebAudioNodes\n    {\n        return this._nodes;\n    }\n\n    // Implements load\n    public load(callback?: LoadedCallback): void\n    {\n        // Load from the arraybuffer, incase it was loaded outside\n        if (this.source)\n        {\n            this._decode(this.source, callback);\n        }\n        // Load from the file path\n        else if (this.parent.url)\n        {\n            this._loadUrl(callback);\n        }\n        else if (callback)\n        {\n            callback(new Error('sound.url or sound.source must be set'));\n        }\n        else\n        {\n            console.error('sound.url or sound.source must be set');\n        }\n    }\n\n    /** Loads a sound using XHMLHttpRequest object. */\n    private _loadUrl(callback?: LoadedCallback): void\n    {\n        const request = new XMLHttpRequest();\n        const url: string = this.parent.url;\n\n        request.open('GET', url, true);\n        request.responseType = 'arraybuffer';\n\n        // Decode asynchronously\n        request.onload = () =>\n        {\n            this.source = request.response as ArrayBuffer;\n            this._decode(request.response, callback);\n        };\n\n        // actually start the request\n        request.send();\n    }\n\n    /**\n     * Decodes the array buffer.\n     * @param arrayBuffer - From load.\n     * @param {Function} callback - Callback optional\n     */\n    private _decode(arrayBuffer: ArrayBuffer, callback?: LoadedCallback): void\n    {\n        const context = this.parent.context as WebAudioContext;\n\n        context.decode(arrayBuffer, (err: Error, buffer: AudioBuffer) =>\n        {\n            if (err)\n            {\n                if (callback)\n                {\n                    callback(err);\n                }\n            }\n            else\n            {\n                this.parent.isLoaded = true;\n                this.buffer = buffer;\n                const instance = this.parent.autoPlayStart();\n\n                if (callback)\n                {\n                    callback(null, this.parent, instance);\n                }\n            }\n        });\n    }\n}\n\nexport { WebAudioMedia };\n","import { Filter } from './filters/Filter';\nimport { HTMLAudioMedia } from './htmlaudio/HTMLAudioMedia';\nimport { getInstance } from './instance';\nimport { IMedia, IMediaContext, IMediaInstance } from './interfaces';\nimport { SoundSprite, SoundSpriteData, SoundSprites } from './SoundSprite';\nimport { resolveUrl } from './utils/resolveUrl';\nimport { WebAudioMedia } from './webaudio/WebAudioMedia';\n\n/**\n * Options to use for creating sounds.\n */\ninterface Options {\n    /**\n     * `true` to immediately start preloading.\n     * @type {boolean}\n     * @default false\n     */\n    autoPlay?: boolean;\n    /**\n     * `true` to disallow playing multiple layered instances at once.\n     * @type {boolean}\n     * @default false\n     */\n    singleInstance?: boolean;\n    /**\n     * The amount of volume 1 = 100%.\n     * @type {number}\n     * @default 1\n     */\n    volume?: number;\n    /**\n     * The playback rate where 1 is 100% speed.\n     * @type {number}\n     * @default 1\n     */\n    speed?: number;\n    /**\n     * Global complete callback when play is finished.\n     * @type {Function}\n     */\n    complete?: CompleteCallback;\n    /**\n     * Call when finished loading.\n     * @type {Function}\n     */\n    loaded?: LoadedCallback;\n    /**\n     * `true` to immediately start preloading if loading from `url`.\n     * @type {boolean}\n     */\n    preload?: boolean;\n    /**\n     * Initial loop value, `true` is loop infinitely\n     * @type {boolean}\n     * @default false\n     */\n    loop?: boolean;\n    /**\n     * The source of the file being loaded\n     * @type {string}\n     */\n    url?: string;\n    /**\n     * If sound is already preloaded, available.\n     * @type {ArrayBuffer|HTMLAudioElement}\n     */\n    source?: ArrayBuffer | HTMLAudioElement;\n    /**\n     * The map of sprite data. Where a sprite is an object\n     * with a `start` and `end`, which are the times in seconds. Optionally, can include\n     * a `speed` amount where 1 is 100% speed.\n     * @type {Object<string, SoundSpriteData>}\n     */\n    sprites?: {[id: string]: SoundSpriteData};\n}\n\n/**\n * Options used for sound playback.\n */\ninterface PlayOptions {\n    /**\n     * Start time offset in seconds.\n     * @type {number}\n     * @default 0\n     */\n    start?: number;\n    /**\n     * End time in seconds.\n     * @type {number}\n     */\n    end?: number;\n    /**\n     * Override default speed, default to the Sound's speed setting.\n     * @type {number}\n     */\n    speed?: number;\n    /**\n    * Override default loop, default to the Sound's loop setting.\n    * @type {number}\n    */\n    loop?: boolean;\n    /**\n     * Override default volume, default to the Sound's volume setting.\n     * @type {number}\n     */\n    volume?: number;\n    /**\n     * The sprite to play.\n     * @type {string}\n     */\n    sprite?: string;\n    /**\n     * If sound instance is muted by default.\n     * @type {boolean}\n     * @default false\n     */\n    muted?: boolean;\n    /**\n     * When completed.\n     * @type {Function}\n     */\n    complete?: CompleteCallback;\n    /**\n     * If not already preloaded, callback when finishes load.\n     * @type {Function}\n     */\n    loaded?: LoadedCallback;\n}\n\n/**\n * Callback when sound is loaded.\n * @ignore\n * @param {Error} err - The callback error.\n * @param {Sound} sound - The instance of new sound.\n * @param {IMediaInstance} instance - The instance of auto-played sound.\n */\ntype LoadedCallback = (err: Error, sound?: Sound, instance?: IMediaInstance) => void;\n\n/**\n * Callback when sound is completed.\n * @ignore\n * @param {Sound} sound - The instance of sound.\n */\ntype CompleteCallback = (sound: Sound) => void;\n\ntype SoundSpriteDataMap = {[id: string]: SoundSpriteData};\n\n/**\n * Sound represents a single piece of loaded media. When playing a sound {@link IMediaInstance} objects\n * are created. Properties such a `volume`, `pause`, `mute`, `speed`, etc will have an effect on all instances.\n * @class\n */\nclass Sound\n{\n    /**\n     * Pool of instances\n     * @type {Array<IMediaInstance>}\n     */\n    private static _pool: IMediaInstance[] = [];\n\n    /**\n     * `true` if the buffer is loaded.\n     * @type {boolean}\n     * @default false\n     */\n    public isLoaded: boolean;\n\n    /**\n     * `true` if the sound is currently being played.\n     * @type {boolean}\n     * @default false\n     * @readonly\n     */\n    public isPlaying: boolean;\n\n    /**\n     * true to start playing immediate after load.\n     * @type {boolean}\n     * @default false\n     * @readonly\n     */\n    public autoPlay: boolean;\n\n    /**\n     * `true` to disallow playing multiple layered instances at once.\n     * @type {boolean}\n     * @default false\n     */\n    public singleInstance: boolean;\n\n    /**\n     * `true` to immediately start preloading.\n     * @type {boolean}\n     * @default false\n     * @readonly\n     */\n    public preload: boolean;\n\n    /**\n     * The file source to load.\n     * @type {String}\n     * @readonly\n     */\n    public url: string;\n\n    /**\n     * The constructor options.\n     * @type {Object}\n     * @readonly\n     */\n    public options: Options;\n\n    /**\n     * The audio source\n     * @type {IMedia}\n     */\n    public media: IMedia;\n\n    /**\n     * The collection of instances being played.\n     * @type {Array<IMediaInstance>}\n     */\n    private _instances: IMediaInstance[];\n\n    /**\n     * Reference to the sound context.\n     * @type {SoundContext}\n     */\n    private _sprites: SoundSprites;\n\n    /**\n     * The options when auto-playing.\n     * @type {PlayOptions}\n     */\n    private _autoPlayOptions: PlayOptions;\n\n    /**\n     * The internal volume.\n     * @type {number}\n     */\n    private _volume: number;\n\n    /**\n     * The internal paused state.\n     * @type {boolean}\n     */\n    private _paused: boolean;\n\n    /**\n     * The internal muted state.\n     * @type {boolean}\n     */\n    private _muted: boolean;\n\n    /**\n     * The internal volume.\n     * @type {boolean}\n     */\n    private _loop: boolean;\n\n    /**\n     * The internal playbackRate\n     * @type {number}\n     */\n    private _speed: number;\n\n    /**\n     * Create a new sound instance from source.\n     * @param {ArrayBuffer|String|Options|HTMLAudioElement} options - Either the path or url to the source file.\n     *        or the object of options to use.\n     * @return Created sound instance.\n     */\n    public static from(source: string | Options | ArrayBuffer | HTMLAudioElement): Sound\n    {\n        let options: Options = {};\n\n        if (typeof source === 'string')\n        {\n            options.url = source as string;\n        }\n        else if (source instanceof ArrayBuffer || source instanceof HTMLAudioElement)\n        {\n            options.source = source;\n        }\n        else\n        {\n            options = source;\n        }\n\n        // Default settings\n        options = {\n            autoPlay: false,\n            singleInstance: false,\n            url: null,\n            source: null,\n            preload: false,\n            volume: 1,\n            speed: 1,\n            complete: null,\n            loaded: null,\n            loop: false, ...options };\n\n        // Resolve url in-case it has a special format\n        if (options.url)\n        {\n            options.url = resolveUrl(options.url);\n        }\n\n        Object.freeze(options);\n\n        const media: IMedia = getInstance().useLegacy\n            ? new HTMLAudioMedia()\n            : new WebAudioMedia();\n\n        return new Sound(media, options);\n    }\n\n    /**\n     * Use `Sound.from`\n     * @ignore\n     */\n    constructor(media: IMedia, options: Options)\n    {\n        this.media = media;\n        this.options = options;\n        this._instances = [];\n        this._sprites = {};\n\n        this.media.init(this);\n\n        const complete = options.complete;\n\n        this._autoPlayOptions = complete ? { complete } : null;\n        this.isLoaded = false;\n        this.isPlaying = false;\n        this.autoPlay = options.autoPlay;\n        this.singleInstance = options.singleInstance;\n        this.preload = options.preload || this.autoPlay;\n        this.url = options.url;\n        this.speed = options.speed;\n        this.volume = options.volume;\n        this.loop = options.loop;\n\n        if (options.sprites)\n        {\n            this.addSprites(options.sprites);\n        }\n\n        if (this.preload)\n        {\n            this._preload(options.loaded);\n        }\n    }\n\n    /**\n     * Instance of the media context\n     * @type {IMediaContext}\n     */\n    public get context(): IMediaContext\n    {\n        return getInstance().context;\n    }\n\n    /**\n     * Stops all the instances of this sound from playing.\n     * @return Instance of this sound.\n     */\n    public pause(): this\n    {\n        this.isPlaying = false;\n        this.paused = true;\n\n        return this;\n    }\n\n    /**\n     * Resuming all the instances of this sound from playing\n     * @return Instance of this sound.\n     */\n    public resume(): this\n    {\n        this.isPlaying = this._instances.length > 0;\n        this.paused = false;\n\n        return this;\n    }\n\n    /** Stops all the instances of this sound from playing. */\n    public get paused(): boolean\n    {\n        return this._paused;\n    }\n    public set paused(paused: boolean)\n    {\n        this._paused = paused;\n        this.refreshPaused();\n    }\n\n    /** The playback rate */\n    public get speed(): number\n    {\n        return this._speed;\n    }\n    public set speed(speed: number)\n    {\n        this._speed = speed;\n        this.refresh();\n    }\n\n    /**\n     * Set the filters. Only supported with WebAudio.\n     * @type {Array<filters.Filter>}\n     */\n    public get filters(): Filter[]\n    {\n        return this.media.filters;\n    }\n    public set filters(filters: Filter[])\n    {\n        this.media.filters = filters;\n    }\n\n    /**\n     * Add a sound sprite, which is a saved instance of a longer sound.\n     * Similar to an image spritesheet.\n     * @param {String} alias - The unique name of the sound sprite.\n     * @param {object} data - Either completed function or play options.\n     * @param {number} data.start - Time when to play the sound in seconds.\n     * @param {number} data.end - Time to end playing in seconds.\n     * @param {number} data.speed - Override default speed, default to the Sound's speed setting.\n     * @return Sound sprite result.\n     */\n    public addSprites(alias: string, data: SoundSpriteData): SoundSprite;\n\n    /**\n     * Convenience method to add more than one sprite add a time.\n     * @param {Object} data - Map of sounds to add where the key is the alias,\n     *        and the data are configuration options, see {@link Sound#addSprite} for info on data.\n     * @return The map of sound sprites added.\n     */\n    public addSprites(sprites: SoundSpriteDataMap): SoundSprites;\n\n    /**\n     * @ignore\n     */\n    public addSprites(source: string | SoundSpriteDataMap, data?: SoundSpriteData): any\n    {\n        if (typeof source === 'object')\n        {\n            const results: SoundSprites = {};\n\n            for (const alias in source)\n            {\n                results[alias] = this.addSprites(alias, source[alias]);\n            }\n\n            return results;\n        }\n\n        // eslint-disable-next-line no-console\n        console.assert(!this._sprites[source], `Alias ${source} is already taken`);\n        const sprite = new SoundSprite(this, data);\n\n        this._sprites[source] = sprite;\n\n        return sprite;\n    }\n\n    /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */\n    public destroy(): void\n    {\n        this._removeInstances();\n        this.removeSprites();\n        this.media.destroy();\n        this.media = null;\n        this._sprites = null;\n        this._instances = null;\n    }\n\n    /**\n     * Remove a sound sprite.\n     * @param {String} alias - The unique name of the sound sprite, if alias is omitted, removes all sprites.\n     * @return Sound instance for chaining.\n     */\n    public removeSprites(alias?: string): Sound\n    {\n        if (!alias)\n        {\n            for (const name in this._sprites)\n            {\n                this.removeSprites(name);\n            }\n        }\n        else\n        {\n            const sprite: SoundSprite = this._sprites[alias];\n\n            if (sprite !== undefined)\n            {\n                sprite.destroy();\n                delete this._sprites[alias];\n            }\n        }\n\n        return this;\n    }\n\n    /** If the current sound is playable (loaded). */\n    public get isPlayable(): boolean\n    {\n        return this.isLoaded && this.media && this.media.isPlayable;\n    }\n\n    /**\n     * Stops all the instances of this sound from playing.\n     * @return Instance of this sound.\n     */\n    public stop(): this\n    {\n        if (!this.isPlayable)\n        {\n            this.autoPlay = false;\n            this._autoPlayOptions = null;\n\n            return this;\n        }\n        this.isPlaying = false;\n\n        // Go in reverse order so we don't skip items\n        for (let i = this._instances.length - 1; i >= 0; i--)\n        {\n            this._instances[i].stop();\n        }\n\n        return this;\n    }\n\n    /**\n     * Play a sound sprite, which is a saved instance of a longer sound.\n     * Similar to an image spritesheet.\n     * @method play\n     * @instance\n     * @param alias - The unique name of the sound sprite.\n     * @param {Function} callback - Callback when completed.\n     * @return The sound instance,\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\n     *        has not yet loaded.\n     */\n    public play(alias: string, callback?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>;\n\n    /**\n     * Plays the sound.\n     * @method play\n     * @instance\n     * @param {Function|PlayOptions} options - Either completed function or play options.\n     * @return The sound instance,\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\n     *        has not yet loaded.\n     */\n    public play(source?: string | PlayOptions | CompleteCallback,\n                callback?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>;\n\n    // Overloaded function\n    public play(source?: string | PlayOptions | CompleteCallback,\n        complete?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>\n    {\n        let options: PlayOptions;\n\n        if (typeof source === 'string')\n        {\n            const sprite: string = source as string;\n\n            options = { sprite, loop: this.loop, complete };\n        }\n        else if (typeof source === 'function')\n        {\n            options = {};\n            options.complete = source as CompleteCallback;\n        }\n        else\n        {\n            options = source as PlayOptions;\n        }\n\n        options = {\n            complete: null,\n            loaded: null,\n            sprite: null,\n            end: null,\n            start: 0,\n            volume: 1,\n            speed: 1,\n            muted: false,\n            loop: false, ...(options || {}) };\n\n        // A sprite is specified, add the options\n        if (options.sprite)\n        {\n            const alias: string = options.sprite;\n\n            // eslint-disable-next-line no-console\n            console.assert(!!this._sprites[alias], `Alias ${alias} is not available`);\n            const sprite: SoundSprite = this._sprites[alias];\n\n            options.start = sprite.start + (options.start || 0);\n            options.end = sprite.end;\n            options.speed = sprite.speed || 1;\n            options.loop = sprite.loop || options.loop;\n            delete options.sprite;\n        }\n\n        // @deprecated offset option\n        if ((options as any).offset)\n        {\n            options.start = (options as any).offset as number;\n        }\n\n        // if not yet playable, ignore\n        // - usefull when the sound download isnt yet completed\n        if (!this.isLoaded)\n        {\n            return new Promise<IMediaInstance>((resolve, reject) =>\n            {\n                this.autoPlay = true;\n                this._autoPlayOptions = options;\n                this._preload((err: Error, sound: Sound, media: IMediaInstance) =>\n                {\n                    if (err)\n                    {\n                        reject(err);\n                    }\n                    else\n                    {\n                        if (options.loaded)\n                        {\n                            options.loaded(err, sound, media);\n                        }\n                        resolve(media);\n                    }\n                });\n            });\n        }\n\n        // Stop all sounds\n        if (this.singleInstance)\n        {\n            this._removeInstances();\n        }\n\n        // clone the bufferSource\n        const instance = this._createInstance();\n\n        this._instances.push(instance);\n        this.isPlaying = true;\n        instance.once('end', () =>\n        {\n            if (options.complete)\n            {\n                options.complete(this);\n            }\n            this._onComplete(instance);\n        });\n        instance.once('stop', () =>\n        {\n            this._onComplete(instance);\n        });\n\n        instance.play(options);\n\n        return instance;\n    }\n\n    /** Internal only, speed, loop, volume change occured. */\n    public refresh(): void\n    {\n        const len = this._instances.length;\n\n        for (let i = 0; i < len; i++)\n        {\n            this._instances[i].refresh();\n        }\n    }\n\n    /** Handle changes in paused state. Internal only. */\n    public refreshPaused(): void\n    {\n        const len = this._instances.length;\n\n        for (let i = 0; i < len; i++)\n        {\n            this._instances[i].refreshPaused();\n        }\n    }\n\n    /** Gets and sets the volume. */\n    public get volume(): number\n    {\n        return this._volume;\n    }\n    public set volume(volume: number)\n    {\n        this._volume = volume;\n        this.refresh();\n    }\n\n    /** Gets and sets the muted flag. */\n    public get muted(): boolean\n    {\n        return this._muted;\n    }\n    public set muted(muted: boolean)\n    {\n        this._muted = muted;\n        this.refresh();\n    }\n\n    /** Gets and sets the looping. */\n    public get loop(): boolean\n    {\n        return this._loop;\n    }\n    public set loop(loop: boolean)\n    {\n        this._loop = loop;\n        this.refresh();\n    }\n\n    /**\n     * Starts the preloading of sound.\n     * @private\n     */\n    private _preload(callback?: LoadedCallback): void\n    {\n        this.media.load(callback);\n    }\n\n    /**\n     * Gets the list of instances that are currently being played of this sound.\n     * @type {Array<IMediaInstance>}\n     */\n    public get instances(): IMediaInstance[]\n    {\n        return this._instances;\n    }\n\n    /**\n     * Get the map of sprites.\n     * @type {Object}\n     */\n    public get sprites(): SoundSprites\n    {\n        return this._sprites;\n    }\n\n    /** Get the duration of the audio in seconds. */\n    public get duration(): number\n    {\n        return this.media.duration;\n    }\n\n    /** Auto play the first instance. */\n    public autoPlayStart(): IMediaInstance\n    {\n        let instance: IMediaInstance;\n\n        if (this.autoPlay)\n        {\n            instance = this.play(this._autoPlayOptions) as IMediaInstance;\n        }\n\n        return instance;\n    }\n\n    /**\n     * Removes all instances.\n     * @private\n     */\n    private _removeInstances(): void\n    {\n        // destroying also stops\n        for (let i = this._instances.length - 1; i >= 0; i--)\n        {\n            this._poolInstance(this._instances[i]);\n        }\n        this._instances.length = 0;\n    }\n\n    /**\n     * Sound instance completed.\n     * @private\n     * @param {IMediaInstance} instance\n     */\n    private _onComplete(instance: IMediaInstance): void\n    {\n        if (this._instances)\n        {\n            const index = this._instances.indexOf(instance);\n\n            if (index > -1)\n            {\n                this._instances.splice(index, 1);\n            }\n            this.isPlaying = this._instances.length > 0;\n        }\n        this._poolInstance(instance);\n    }\n\n    /**\n     * Create a new instance.\n     * @private\n     * @return New instance to use\n     */\n    private _createInstance(): IMediaInstance\n    {\n        if (Sound._pool.length > 0)\n        {\n            const instance: IMediaInstance = Sound._pool.pop();\n\n            instance.init(this.media);\n\n            return instance;\n        }\n\n        return this.media.create();\n    }\n\n    /**\n     * Destroy/recycling the instance object.\n     * @private\n     * @param instance - - Instance to recycle\n     */\n    private _poolInstance(instance: IMediaInstance): void\n    {\n        instance.destroy();\n        // Add it if it isn't already added\n        if (Sound._pool.indexOf(instance) < 0)\n        {\n            Sound._pool.push(instance);\n        }\n    }\n}\n\nexport { Sound };\nexport type {\n    Options,\n    PlayOptions,\n    LoadedCallback,\n    CompleteCallback,\n    SoundSpriteDataMap\n};\n","import { EventEmitter } from '@pixi/utils';\nimport { Filter } from '../filters/Filter';\nimport { IMediaContext } from '../interfaces/IMediaContext';\n\n/**\n * The fallback version of WebAudioContext which uses `<audio>` instead of WebAudio API.\n * @class\n * @extends PIXI.util.EventEmitter\n * @memberof htmlaudio\n */\nclass HTMLAudioContext extends EventEmitter implements IMediaContext\n{\n    /** Current global speed from 0 to 1 */\n    public speed = 1;\n\n    /** Current muted status of the context */\n    public muted = false;\n\n    /** Current volume from 0 to 1  */\n    public volume = 1;\n\n    /** Current paused status */\n    public paused = false;\n\n    /** Internal trigger when volume, mute or speed changes */\n    public refresh(): void\n    {\n        this.emit('refresh');\n    }\n\n    /** Internal trigger paused changes */\n    public refreshPaused(): void\n    {\n        this.emit('refreshPaused');\n    }\n\n    /**\n     * HTML Audio does not support filters, this is non-functional API.\n     * @type {Array<Filter>}\n     */\n    public get filters(): Filter[]\n    {\n        console.warn('HTML Audio does not support filters');\n\n        return null;\n    }\n    public set filters(_filters: Filter[])\n    {\n        console.warn('HTML Audio does not support filters');\n    }\n\n    /**\n     * HTML Audio does not support `audioContext`\n     * @readonly\n     * @type {AudioContext}\n     */\n    public get audioContext(): AudioContext\n    {\n        console.warn('HTML Audio does not support audioContext');\n\n        return null;\n    }\n\n    /**\n     * Toggles the muted state.\n     * @return The current muted state.\n     */\n    public toggleMute(): boolean\n    {\n        this.muted = !this.muted;\n        this.refresh();\n\n        return this.muted;\n    }\n\n    /**\n     * Toggles the paused state.\n     * @return The current paused state.\n     */\n    public togglePause(): boolean\n    {\n        this.paused = !this.paused;\n        this.refreshPaused();\n\n        return this.paused;\n    }\n\n    /** Destroy and don't use after this */\n    public destroy(): void\n    {\n        this.removeAllListeners();\n    }\n}\n\nexport { HTMLAudioContext };\n","import { EventEmitter } from '@pixi/utils';\nimport { Filterable } from '../Filterable';\nimport { IMediaContext } from '../interfaces';\n\n/**\n * Main class to handle WebAudio API. There's a simple chain\n * of AudioNode elements: analyser > compressor > context.destination.\n * any filters that are added are inserted between the analyser and compressor nodes\n * @class\n * @memberof webaudio\n */\nclass WebAudioContext extends Filterable implements IMediaContext\n{\n    /**\n     * Context Compressor node\n     * @readonly\n     */\n    public compressor: DynamicsCompressorNode;\n\n    /**\n     * Context Analyser node\n     * @readonly\n     */\n    public analyser: AnalyserNode;\n\n    /**\n     * Global speed of all sounds\n     * @readonly\n     */\n    public speed: number;\n\n    /**\n     * Sets the muted state.\n     * @default false\n     */\n    public muted: boolean;\n\n    /**\n     * Sets the volume from 0 to 1.\n     * @default 1\n     */\n    public volume: number;\n\n    /**\n     * Handle global events\n     * @type {PIXI.utils.EventEmitter}\n     */\n    public events: EventEmitter;\n\n    /** The instance of the AudioContext for WebAudio API. */\n    private _ctx: AudioContext;\n\n    /** The instance of the OfflineAudioContext for fast decoding audio. */\n    private _offlineCtx: OfflineAudioContext;\n\n    /** Current paused status */\n    private _paused: boolean;\n\n    /**\n     * Indicated whether audio on iOS has been unlocked, which requires a touchend/mousedown event that plays an\n     * empty sound.\n     * @type {boolean}\n     */\n    private _unlocked: boolean;\n\n    constructor()\n    {\n        const win: any = window as any;\n        const ctx = new WebAudioContext.AudioContext();\n        const compressor: DynamicsCompressorNode = ctx.createDynamicsCompressor();\n        const analyser: AnalyserNode = ctx.createAnalyser();\n\n        // setup the end of the node chain\n        analyser.connect(compressor);\n        compressor.connect(ctx.destination);\n\n        super(analyser, compressor);\n\n        this._ctx = ctx;\n        // ios11 safari's webkitOfflineAudioContext allows only 44100 Hz sample rate\n        this._offlineCtx = new WebAudioContext.OfflineAudioContext(1, 2,\n            (win.OfflineAudioContext) ? ctx.sampleRate : 44100);\n        this._unlocked = false;\n\n        this.compressor = compressor;\n        this.analyser = analyser;\n        this.events = new EventEmitter();\n\n        // Set the defaults\n        this.volume = 1;\n        this.speed = 1;\n        this.muted = false;\n        this.paused = false;\n\n        // Listen for document level clicks to unlock WebAudio. See the _unlock method.\n        if (ctx.state !== 'running')\n        {\n            this._unlock(); // When played inside of a touch event, this will enable audio on iOS immediately.\n            this._unlock = this._unlock.bind(this);\n            document.addEventListener('mousedown', this._unlock, true);\n            document.addEventListener('touchstart', this._unlock, true);\n            document.addEventListener('touchend', this._unlock, true);\n        }\n    }\n\n    /**\n     * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of\n     * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend\n     * will fail if the user presses for too long, indicating a scroll event instead of a click event.\n     *\n     * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding\n     * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we\n     * stick with `mousedown` and `touchend`.\n     */\n    private _unlock(): void\n    {\n        if (this._unlocked)\n        {\n            return;\n        }\n        this.playEmptySound();\n        if (this._ctx.state === 'running')\n        {\n            document.removeEventListener('mousedown', this._unlock, true);\n            document.removeEventListener('touchend', this._unlock, true);\n            document.removeEventListener('touchstart', this._unlock, true);\n            this._unlocked = true;\n        }\n    }\n\n    /**\n     * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they\n     * require the first sound to be played inside of a user initiated event (touch/click).\n     */\n    public playEmptySound(): void\n    {\n        const source = this._ctx.createBufferSource();\n\n        source.buffer = this._ctx.createBuffer(1, 1, 22050);\n        source.connect(this._ctx.destination);\n        source.start(0, 0, 0);\n        if (source.context.state === 'suspended')\n        {\n            (source.context as AudioContext).resume();\n        }\n    }\n\n    /**\n     * Get AudioContext class, if not supported returns `null`\n     * @readonly\n     * @type {AudioContext}\n     */\n    public static get AudioContext(): typeof AudioContext\n    {\n        const win: any = window as any;\n\n        return (\n            win.AudioContext\n            || win.webkitAudioContext\n            || null\n        );\n    }\n\n    /**\n     * Get OfflineAudioContext class, if not supported returns `null`\n     * @type {OfflineAudioContext}\n     * @readonly\n     */\n    public static get OfflineAudioContext(): typeof OfflineAudioContext\n    {\n        const win: any = window as any;\n\n        return (\n            win.OfflineAudioContext\n            || win.webkitOfflineAudioContext\n            || null\n        );\n    }\n\n    /** Destroy this context. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        const ctx: any = this._ctx as any;\n        // check if browser supports AudioContext.close()\n\n        if (typeof ctx.close !== 'undefined')\n        {\n            ctx.close();\n        }\n        this.events.removeAllListeners();\n        this.analyser.disconnect();\n        this.compressor.disconnect();\n        this.analyser = null;\n        this.compressor = null;\n        this.events = null;\n        this._offlineCtx = null;\n        this._ctx = null;\n    }\n\n    /**\n     * The WebAudio API AudioContext object.\n     * @readonly\n     * @type {AudioContext}\n     */\n    public get audioContext(): AudioContext\n    {\n        return this._ctx;\n    }\n\n    /**\n     * The WebAudio API OfflineAudioContext object.\n     * @readonly\n     * @type {OfflineAudioContext}\n     */\n    public get offlineContext(): OfflineAudioContext\n    {\n        return this._offlineCtx;\n    }\n\n    /**\n     * Pauses all sounds, even though we handle this at the instance\n     * level, we'll also pause the audioContext so that the\n     * time used to compute progress isn't messed up.\n     * @type {boolean}\n     * @default false\n     */\n    public set paused(paused: boolean)\n    {\n        if (paused && this._ctx.state === 'running')\n        {\n            (this._ctx as any).suspend();\n        }\n        else if (!paused && this._ctx.state === 'suspended')\n        {\n            (this._ctx as any).resume();\n        }\n        this._paused = paused;\n    }\n    public get paused(): boolean\n    {\n        return this._paused;\n    }\n\n    /** Emit event when muted, volume or speed changes */\n    public refresh(): void\n    {\n        this.events.emit('refresh');\n    }\n\n    /** Emit event when muted, volume or speed changes */\n    public refreshPaused(): void\n    {\n        this.events.emit('refreshPaused');\n    }\n\n    /**\n     * Toggles the muted state.\n     * @return The current muted state.\n     */\n    public toggleMute(): boolean\n    {\n        this.muted = !this.muted;\n        this.refresh();\n\n        return this.muted;\n    }\n\n    /**\n     * Toggles the paused state.\n     * @return The current muted state.\n     */\n    public togglePause(): boolean\n    {\n        this.paused = !this.paused;\n        this.refreshPaused();\n\n        return this._paused;\n    }\n\n    /**\n     * Decode the audio data\n     * @param {ArrayBuffer} arrayBuffer - Buffer from loader\n     * @param {Function} callback - When completed, error and audioBuffer are parameters.\n     */\n    public decode(arrayBuffer: ArrayBuffer, callback: (err?: Error, buffer?: AudioBuffer) => void): void\n    {\n        const handleError = (err: Error) =>\n        {\n            callback(new Error(err.message || 'Unable to decode file'));\n        };\n        const result = this._offlineCtx.decodeAudioData(\n            arrayBuffer, (buffer: AudioBuffer) =>\n            {\n                callback(null, buffer);\n            },\n            handleError,\n        );\n        // Reference: https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/decodeAudioData\n        // decodeAudioData return value: Void, or a Promise object that fulfills with the decodedData.\n\n        if (result)\n        {\n            result.catch(handleError);\n        }\n    }\n}\n\nexport { WebAudioContext };\n","import { Filter } from './filters/Filter';\nimport { IMediaContext } from './interfaces/IMediaContext';\nimport { IMediaInstance } from './interfaces/IMediaInstance';\nimport { SoundLoader } from './SoundLoader';\nimport { CompleteCallback, Options, PlayOptions, Sound } from './Sound';\nimport { HTMLAudioContext } from './htmlaudio/HTMLAudioContext';\nimport { WebAudioContext } from './webaudio/WebAudioContext';\n\ntype SoundSourceMap = {[id: string]: Options | string | ArrayBuffer | HTMLAudioElement};\ntype SoundMap = {[id: string]: Sound};\n\n/**\n * Manages the playback of sounds. This is the main class for PixiJS Sound. If you're\n * using the browser-based bundled this is `PIXI.sound`. Otherwise, you can do this:\n * @example\n * import { sound } from '@pixi/sound';\n *\n * // sound is an instance of SoundLibrary\n * sound.add('my-sound', 'path/to/file.mp3');\n * sound.play('my-sound');\n * @class\n */\nclass SoundLibrary\n{\n    /**\n     * For legacy approach for Audio. Instead of using WebAudio API\n     * for playback of sounds, it will use HTML5 `<audio>` element.\n     */\n    private _useLegacy: boolean;\n\n    /** The global context to use. */\n    private _context: IMediaContext;\n\n    /** The WebAudio specific context */\n    private _webAudioContext: WebAudioContext;\n\n    /** The HTML Audio (legacy) context. */\n    private _htmlAudioContext: HTMLAudioContext;\n\n    /** The map of all sounds by alias. */\n    private _sounds: SoundMap;\n\n    constructor()\n    {\n        this.init();\n    }\n\n    /**\n     * Re-initialize the sound library, this will\n     * recreate the AudioContext. If there's a hardware-failure\n     * call `close` and then `init`.\n     * @return Sound instance\n     */\n    public init(): this\n    {\n        if (this.supported)\n        {\n            this._webAudioContext = new WebAudioContext();\n        }\n        this._htmlAudioContext = new HTMLAudioContext();\n        this._sounds = {};\n        this.useLegacy = !this.supported;\n\n        return this;\n    }\n\n    /**\n     * The global context to use.\n     * @type {IMediaContext}\n     * @readonly\n     */\n    public get context(): IMediaContext\n    {\n        return this._context;\n    }\n\n    /**\n     * Apply filters to all sounds. Can be useful\n     * for setting global planning or global effects.\n     * **Only supported with WebAudio.**\n     * @example\n     * import { sound, filters } from '@pixi/sound';\n     * // Adds a filter to pan all output left\n     * sound.filtersAll = [\n     *     new filters.StereoFilter(-1)\n     * ];\n     * @type {filters.Filter[]}\n     */\n    public get filtersAll(): Filter[]\n    {\n        if (!this.useLegacy)\n        {\n            return this._context.filters;\n        }\n\n        return [];\n    }\n    public set filtersAll(filtersAll: Filter[])\n    {\n        if (!this.useLegacy)\n        {\n            this._context.filters = filtersAll;\n        }\n    }\n\n    /**\n     * `true` if WebAudio is supported on the current browser.\n     * @readonly\n     * @type {boolean}\n     */\n    public get supported(): boolean\n    {\n        return WebAudioContext.AudioContext !== null;\n    }\n\n    /**\n     * Register an existing sound with the library cache.\n     * @method add\n     * @instance\n     * @param {string} alias - The sound alias reference.\n     * @param {Sound} sound - Sound reference to use.\n     * @return {Sound} Instance of the Sound object.\n     */\n\n    /**\n     * Adds a new sound by alias.\n     * @param alias - The sound alias reference.\n     * @param {ArrayBuffer|String|Options|HTMLAudioElement} options - Either the path or url to the source file.\n     *        or the object of options to use.\n     * @return Instance of the Sound object.\n     */\n    public add(alias: string, options: Options | string | ArrayBuffer | HTMLAudioElement | Sound): Sound;\n\n    /**\n     * Adds multiple sounds at once.\n     * @param map - Map of sounds to add, the key is the alias, the value is the\n     *        `string`, `ArrayBuffer`, `HTMLAudioElement` or the list of options\n     *        (see {@link Options} for full options).\n     * @param globalOptions - The default options for all sounds.\n     *        if a property is defined, it will use the local property instead.\n     * @return Instance to the Sound object.\n     */\n    public add(map: SoundSourceMap, globalOptions?: Options): SoundMap;\n\n    /**\n     * @ignore\n     */\n    public add(source: string | SoundSourceMap,\n        sourceOptions?: Options | string | ArrayBuffer | HTMLAudioElement | Sound): any\n    {\n        if (typeof source === 'object')\n        {\n            const results: SoundMap = {};\n\n            for (const alias in source)\n            {\n                const options: Options = this._getOptions(\n                    source[alias],\n                    sourceOptions as Options,\n                );\n\n                results[alias] = this.add(alias, options);\n            }\n\n            return results;\n        }\n\n        // eslint-disable-next-line no-console\n        console.assert(!this._sounds[source], `Sound with alias ${source} already exists.`);\n\n        if (sourceOptions instanceof Sound)\n        {\n            this._sounds[source] = sourceOptions;\n\n            return sourceOptions;\n        }\n\n        const options: Options = this._getOptions(sourceOptions);\n        const sound: Sound = Sound.from(options);\n\n        this._sounds[source] = sound;\n\n        return sound;\n    }\n\n    /**\n     * Internal methods for getting the options object\n     * @private\n     * @param source - The source options\n     * @param overrides - Override default options\n     * @return The construction options\n     */\n    private _getOptions(source: string | ArrayBuffer | HTMLAudioElement | Options, overrides?: Options): Options\n    {\n        let options: Options;\n\n        if (typeof source === 'string')\n        {\n            options = { url: source };\n        }\n        else if (source instanceof ArrayBuffer || source instanceof HTMLAudioElement)\n        {\n            options = { source };\n        }\n        else\n        {\n            options = source as Options;\n        }\n        options = { ...options, ...(overrides || {}) };\n\n        return options;\n    }\n\n    /**\n     * Do not use WebAudio, force the use of legacy. This **must** be called before loading any files.\n     * @type {boolean}\n     */\n    public get useLegacy(): boolean\n    {\n        return this._useLegacy;\n    }\n    public set useLegacy(legacy: boolean)\n    {\n        SoundLoader.setLegacy(legacy);\n        this._useLegacy = legacy;\n\n        // Set the context to use\n        this._context = (!legacy && this.supported)\n            ? this._webAudioContext\n            : this._htmlAudioContext;\n    }\n\n    /**\n     * Removes a sound by alias.\n     * @param alias - The sound alias reference.\n     * @return Instance for chaining.\n     */\n    public remove(alias: string): this\n    {\n        this.exists(alias, true);\n        this._sounds[alias].destroy();\n        delete this._sounds[alias];\n\n        return this;\n    }\n\n    /**\n     * Set the global volume for all sounds. To set per-sound volume see {@link SoundLibrary#volume}.\n     * @type {number}\n     */\n    public get volumeAll(): number\n    {\n        return this._context.volume;\n    }\n    public set volumeAll(volume: number)\n    {\n        this._context.volume = volume;\n        this._context.refresh();\n    }\n\n    /**\n     * Set the global speed for all sounds. To set per-sound speed see {@link SoundLibrary#speed}.\n     * @type {number}\n     */\n    public get speedAll(): number\n    {\n        return this._context.speed;\n    }\n    public set speedAll(speed: number)\n    {\n        this._context.speed = speed;\n        this._context.refresh();\n    }\n\n    /**\n     * Toggle paused property for all sounds.\n     * @return `true` if all sounds are paused.\n     */\n    public togglePauseAll(): boolean\n    {\n        return this._context.togglePause();\n    }\n\n    /**\n     * Pauses any playing sounds.\n     * @return Instance for chaining.\n     */\n    public pauseAll(): this\n    {\n        this._context.paused = true;\n        this._context.refreshPaused();\n\n        return this;\n    }\n\n    /**\n     * Resumes any sounds.\n     * @return Instance for chaining.\n     */\n    public resumeAll(): this\n    {\n        this._context.paused = false;\n        this._context.refreshPaused();\n\n        return this;\n    }\n\n    /**\n     * Toggle muted property for all sounds.\n     * @return `true` if all sounds are muted.\n     */\n    public toggleMuteAll(): boolean\n    {\n        return this._context.toggleMute();\n    }\n\n    /**\n     * Mutes all playing sounds.\n     * @return Instance for chaining.\n     */\n    public muteAll(): this\n    {\n        this._context.muted = true;\n        this._context.refresh();\n\n        return this;\n    }\n\n    /**\n     * Unmutes all playing sounds.\n     * @return Instance for chaining.\n     */\n    public unmuteAll(): this\n    {\n        this._context.muted = false;\n        this._context.refresh();\n\n        return this;\n    }\n\n    /**\n     * Stops and removes all sounds. They cannot be used after this.\n     * @return Instance for chaining.\n     */\n    public removeAll(): this\n    {\n        for (const alias in this._sounds)\n        {\n            this._sounds[alias].destroy();\n            delete this._sounds[alias];\n        }\n\n        return this;\n    }\n\n    /**\n     * Stops all sounds.\n     * @return Instance for chaining.\n     */\n    public stopAll(): this\n    {\n        for (const alias in this._sounds)\n        {\n            this._sounds[alias].stop();\n        }\n\n        return this;\n    }\n\n    /**\n     * Checks if a sound by alias exists.\n     * @param alias - Check for alias.\n     * @return true if the sound exists.\n     */\n    public exists(alias: string, assert = false): boolean\n    {\n        const exists = !!this._sounds[alias];\n\n        if (assert)\n        {\n            // eslint-disable-next-line no-console\n            console.assert(exists, `No sound matching alias '${alias}'.`);\n        }\n\n        return exists;\n    }\n\n    /**\n     * Find a sound by alias.\n     * @param alias - The sound alias reference.\n     * @return Sound object.\n     */\n    public find(alias: string): Sound\n    {\n        this.exists(alias, true);\n\n        return this._sounds[alias];\n    }\n\n    /**\n     * Plays a sound.\n     * @method play\n     * @instance\n     * @param {string} alias - The sound alias reference.\n     * @param {string} sprite - The alias of the sprite to play.\n     * @return {IMediaInstance|null} The sound instance, this cannot be reused\n     *         after it is done playing. Returns `null` if the sound has not yet loaded.\n     */\n\n    /**\n     * Plays a sound.\n     * @param alias - The sound alias reference.\n     * @param {PlayOptions|Function} options - The options or callback when done.\n     * @return The sound instance,\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\n     *        has not yet loaded.\n     */\n    public play(\n        alias: string,\n        options?: PlayOptions | CompleteCallback | string): IMediaInstance | Promise<IMediaInstance>\n    {\n        return this.find(alias).play(options);\n    }\n\n    /**\n     * Stops a sound.\n     * @param alias - The sound alias reference.\n     * @return Sound object.\n     */\n    public stop(alias: string): Sound\n    {\n        return this.find(alias).stop();\n    }\n\n    /**\n     * Pauses a sound.\n     * @param alias - The sound alias reference.\n     * @return Sound object.\n     */\n    public pause(alias: string): Sound\n    {\n        return this.find(alias).pause();\n    }\n\n    /**\n     * Resumes a sound.\n     * @param alias - The sound alias reference.\n     * @return Instance for chaining.\n     */\n    public resume(alias: string): Sound\n    {\n        return this.find(alias).resume();\n    }\n\n    /**\n     * Get or set the volume for a sound.\n     * @param alias - The sound alias reference.\n     * @param volume - Optional current volume to set.\n     * @return The current volume.\n     */\n    public volume(alias: string, volume?: number): number\n    {\n        const sound = this.find(alias);\n\n        if (volume !== undefined)\n        {\n            sound.volume = volume;\n        }\n\n        return sound.volume;\n    }\n\n    /**\n     * Get or set the speed for a sound.\n     * @param alias - The sound alias reference.\n     * @param speed - Optional current speed to set.\n     * @return The current speed.\n     */\n    public speed(alias: string, speed?: number): number\n    {\n        const sound = this.find(alias);\n\n        if (speed !== undefined)\n        {\n            sound.speed = speed;\n        }\n\n        return sound.speed;\n    }\n\n    /**\n     * Get the length of a sound in seconds.\n     * @param alias - The sound alias reference.\n     * @return The current duration in seconds.\n     */\n    public duration(alias: string): number\n    {\n        return this.find(alias).duration;\n    }\n\n    /**\n     * Closes the sound library. This will release/destroy\n     * the AudioContext(s). Can be used safely if you want to\n     * initialize the sound library later. Use `init` method.\n     */\n    public close(): this\n    {\n        this.removeAll();\n        this._sounds = null;\n        if (this._webAudioContext)\n        {\n            this._webAudioContext.destroy();\n            this._webAudioContext = null;\n        }\n        if (this._htmlAudioContext)\n        {\n            this._htmlAudioContext.destroy();\n            this._htmlAudioContext = null;\n        }\n        this._context = null;\n\n        return this;\n    }\n}\n\nexport { SoundLibrary };\nexport type { SoundSourceMap, SoundMap };\n","import { HTMLAudioMedia } from './HTMLAudioMedia';\nimport { HTMLAudioInstance } from './HTMLAudioInstance';\nimport { HTMLAudioContext } from './HTMLAudioContext';\n\n/**\n * Classes supporting non-WebAudio based browsers.\n * @namespace htmlaudio\n */\nexport default {\n    HTMLAudioContext,\n    HTMLAudioMedia,\n    HTMLAudioInstance,\n};\n","/**\n * Represents a single sound element. Can be used to play, pause, etc. sound instances.\n *\n * @class\n * @memberof filters\n */\nclass Filter\n{\n    /** The node to connect for the filter to the previous filter. */\n    public destination: AudioNode;\n\n    /** The node to connect for the filter to the previous filter. */\n    public source: AudioNode;\n\n    /**\n     * @param {AudioNode} destination - The audio node to use as the destination for the input AudioNode\n     * @param {AudioNode} [source] - Optional output node, defaults to destination node. This is useful\n     *        when creating filters which contains multiple AudioNode elements chained together.\n     */\n    constructor(destination: AudioNode, source?: AudioNode)\n    {\n        this.init(destination, source);\n    }\n\n    /** Reinitialize */\n    protected init(destination: AudioNode, source?: AudioNode): void\n    {\n        this.destination = destination;\n        this.source = source || destination;\n    }\n\n    /**\n     * Connect to the destination.\n     * @param {AudioNode} destination - The destination node to connect the output to\n     */\n    public connect(destination: AudioNode): void\n    {\n        this.source.connect(destination);\n    }\n\n    /** Completely disconnect filter from destination and source nodes. */\n    public disconnect(): void\n    {\n        this.source.disconnect();\n    }\n\n    /** Destroy the filter and don't use after this. */\n    public destroy(): void\n    {\n        this.disconnect();\n        this.destination = null;\n        this.source = null;\n    }\n}\n\nexport { Filter };\n","import { Filter } from './Filter';\nimport { EqualizerFilter } from './EqualizerFilter';\nimport { DistortionFilter } from './DistortionFilter';\nimport { StereoFilter } from './StereoFilter';\nimport { ReverbFilter } from './ReverbFilter';\nimport { MonoFilter } from './MonoFilter';\nimport { TelephoneFilter } from './TelephoneFilter';\n\n/**\n * Set of dynamic filters to be applied to Sound.\n * @example\n * import { Sound, filters } from '@pixi/sound';\n * const sound = Sound.from('file.mp3');\n * sound.filters = [\n *   new filters.StereoFilter(-1),\n *   new filters.ReverbFilter()\n * ];\n * @namespace filters\n */\nexport default {\n    Filter,\n    EqualizerFilter,\n    DistortionFilter,\n    StereoFilter,\n    ReverbFilter,\n    MonoFilter,\n    TelephoneFilter\n};\n","import { getInstance } from '../instance';\nimport { WebAudioUtils } from '../webaudio/WebAudioUtils';\nimport { Filter } from './Filter';\n\ninterface Band {\n    f: number;\n    type: string;\n    gain: number;\n}\n\n/**\n * Filter for adding equalizer bands.\n *\n * @class\n * @memberof filters\n * @param {number} [f32=0] - Default gain for 32 Hz\n * @param {number} [f64=0] - Default gain for 64 Hz\n * @param {number} [f125=0] - Default gain for 125 Hz\n * @param {number} [f250=0] - Default gain for 250 Hz\n * @param {number} [f500=0] - Default gain for 500 Hz\n * @param {number} [f1k=0] - Default gain for 1000 Hz\n * @param {number} [f2k=0] - Default gain for 2000 Hz\n * @param {number} [f4k=0] - Default gain for 4000 Hz\n * @param {number} [f8k=0] - Default gain for 8000 Hz\n * @param {number} [f16k=0] - Default gain for 16000 Hz\n */\nclass EqualizerFilter extends Filter\n{\n    /**\n     * Band at 32 Hz\n     * @readonly\n     */\n    public static readonly F32: number = 32;\n\n    /**\n     * Band at 64 Hz\n     * @readonly\n     */\n    public static readonly F64: number = 64;\n\n    /**\n     * Band at 125 Hz\n     * @readonly\n     */\n    public static readonly F125: number = 125;\n\n    /**\n     * Band at 250 Hz\n     * @readonly\n     */\n    public static readonly F250: number = 250;\n\n    /**\n     * Band at 500 Hz\n     * @readonly\n     */\n    public static readonly F500: number = 500;\n\n    /**\n     * Band at 1000 Hz\n     * @readonly\n     */\n    public static readonly F1K: number = 1000;\n\n    /**\n     * Band at 2000 Hz\n     * @readonly\n     */\n    public static readonly F2K: number = 2000;\n\n    /**\n     * Band at 4000 Hz\n     * @readonly\n     */\n    public static readonly F4K: number = 4000;\n\n    /**\n     * Band at 8000 Hz\n     * @readonly\n     */\n    public static readonly F8K: number = 8000;\n\n    /**\n     * Band at 16000 Hz\n     * @readonly\n     */\n    public static readonly F16K: number = 16000;\n\n    /**\n     * The list of bands\n     * @readonly\n     */\n    public readonly bands: BiquadFilterNode[];\n\n    /**\n     * The map of bands to frequency\n     * @type {Object}\n     * @readonly\n     */\n    public readonly bandsMap: {[id: number]: BiquadFilterNode};\n\n    constructor(f32 = 0, f64 = 0, f125 = 0, f250 = 0, f500 = 0,\n        f1k = 0, f2k = 0, f4k = 0, f8k = 0, f16k = 0)\n    {\n        if (getInstance().useLegacy)\n        {\n            super(null);\n\n            return;\n        }\n\n        const equalizerBands: Band[] = [\n            {\n                f: EqualizerFilter.F32,\n                type: 'lowshelf',\n                gain: f32,\n            },\n            {\n                f: EqualizerFilter.F64,\n                type: 'peaking',\n                gain: f64,\n            },\n            {\n                f: EqualizerFilter.F125,\n                type: 'peaking',\n                gain: f125,\n            },\n            {\n                f: EqualizerFilter.F250,\n                type: 'peaking',\n                gain: f250,\n            },\n            {\n                f: EqualizerFilter.F500,\n                type: 'peaking',\n                gain: f500,\n            },\n            {\n                f: EqualizerFilter.F1K,\n                type: 'peaking',\n                gain: f1k,\n            },\n            {\n                f: EqualizerFilter.F2K,\n                type: 'peaking',\n                gain: f2k,\n            },\n            {\n                f: EqualizerFilter.F4K,\n                type: 'peaking',\n                gain: f4k,\n            },\n            {\n                f: EqualizerFilter.F8K,\n                type: 'peaking',\n                gain: f8k,\n            },\n            {\n                f: EqualizerFilter.F16K,\n                type: 'highshelf',\n                gain: f16k,\n            },\n        ];\n\n        const bands: BiquadFilterNode[] = equalizerBands.map((band: Band) =>\n        {\n            const node: BiquadFilterNode = getInstance().context.audioContext.createBiquadFilter();\n\n            node.type = band.type as BiquadFilterType;\n            WebAudioUtils.setParamValue(node.Q, 1);\n            node.frequency.value = band.f; // WebAudioUtils.setParamValue(filter.frequency, band.f);\n            WebAudioUtils.setParamValue(node.gain, band.gain);\n\n            return node;\n        });\n\n        // Setup the constructor AudioNode, where first is the input, and last is the output\n        super(bands[0], bands[bands.length - 1]);\n\n        // Manipulate the bands\n        this.bands = bands;\n\n        // Create a map\n        this.bandsMap = {};\n\n        for (let i = 0; i < this.bands.length; i++)\n        {\n            const node: BiquadFilterNode = this.bands[i];\n\n            // Connect the previous band to the current one\n            if (i > 0)\n            {\n                this.bands[i - 1].connect(node);\n            }\n            this.bandsMap[node.frequency.value] = node;\n        }\n    }\n\n    /**\n     * Set gain on a specific frequency.\n     * @param {number} frequency - The frequency, see EqualizerFilter.F* for bands\n     * @param {number} [gain=0] - Recommended -40 to 40.\n     */\n    public setGain(frequency: number, gain = 0): void\n    {\n        if (!this.bandsMap[frequency])\n        {\n            throw new Error(`No band found for frequency ${frequency}`);\n        }\n        WebAudioUtils.setParamValue(this.bandsMap[frequency].gain, gain);\n    }\n\n    /**\n     * Get gain amount on a specific frequency.\n     * @return The amount of gain set.\n     */\n    public getGain(frequency: number): number\n    {\n        if (!this.bandsMap[frequency])\n        {\n            throw new Error(`No band found for frequency ${frequency}`);\n        }\n\n        return this.bandsMap[frequency].gain.value;\n    }\n\n    /**\n     * Gain at 32 Hz frequencey.\n     * @type {number}\n     * @default 0\n     */\n    public set f32(value: number)\n    {\n        this.setGain(EqualizerFilter.F32, value);\n    }\n    public get f32(): number\n    {\n        return this.getGain(EqualizerFilter.F32);\n    }\n\n    /**\n     * Gain at 64 Hz frequencey.\n     * @type {number}\n     * @default 0\n     */\n    public set f64(value: number)\n    {\n        this.setGain(EqualizerFilter.F64, value);\n    }\n    public get f64(): number\n    {\n        return this.getGain(EqualizerFilter.F64);\n    }\n\n    /**\n     * Gain at 125 Hz frequencey.\n     * @type {number}\n     * @default 0\n     */\n    public set f125(value: number)\n    {\n        this.setGain(EqualizerFilter.F125, value);\n    }\n    public get f125(): number\n    {\n        return this.getGain(EqualizerFilter.F125);\n    }\n\n    /**\n     * Gain at 250 Hz frequencey.\n     * @type {number}\n     * @default 0\n     */\n    public set f250(value: number)\n    {\n        this.setGain(EqualizerFilter.F250, value);\n    }\n    public get f250(): number\n    {\n        return this.getGain(EqualizerFilter.F250);\n    }\n\n    /**\n     * Gain at 500 Hz frequencey.\n     * @type {number}\n     * @default 0\n     */\n    public set f500(value: number)\n    {\n        this.setGain(EqualizerFilter.F500, value);\n    }\n    public get f500(): number\n    {\n        return this.getGain(EqualizerFilter.F500);\n    }\n\n    /**\n     * Gain at 1 KHz frequencey.\n     * @type {number}\n     * @default 0\n     */\n    public set f1k(value: number)\n    {\n        this.setGain(EqualizerFilter.F1K, value);\n    }\n    public get f1k(): number\n    {\n        return this.getGain(EqualizerFilter.F1K);\n    }\n\n    /**\n     * Gain at 2 KHz frequencey.\n     * @type {number}\n     * @default 0\n     */\n    public set f2k(value: number)\n    {\n        this.setGain(EqualizerFilter.F2K, value);\n    }\n    public get f2k(): number\n    {\n        return this.getGain(EqualizerFilter.F2K);\n    }\n\n    /**\n     * Gain at 4 KHz frequencey.\n     * @type {number}\n     * @default 0\n     */\n    public set f4k(value: number)\n    {\n        this.setGain(EqualizerFilter.F4K, value);\n    }\n    public get f4k(): number\n    {\n        return this.getGain(EqualizerFilter.F4K);\n    }\n\n    /**\n     * Gain at 8 KHz frequencey.\n     * @type {number}\n     * @default 0\n     */\n    public set f8k(value: number)\n    {\n        this.setGain(EqualizerFilter.F8K, value);\n    }\n    public get f8k(): number\n    {\n        return this.getGain(EqualizerFilter.F8K);\n    }\n\n    /**\n     * Gain at 16 KHz frequencey.\n     * @type {number}\n     * @default 0\n     */\n    public set f16k(value: number)\n    {\n        this.setGain(EqualizerFilter.F16K, value);\n    }\n    public get f16k(): number\n    {\n        return this.getGain(EqualizerFilter.F16K);\n    }\n\n    /** Reset all frequency bands to have gain of 0 */\n    public reset(): void\n    {\n        this.bands.forEach((band: BiquadFilterNode) =>\n        {\n            WebAudioUtils.setParamValue(band.gain, 0);\n        });\n    }\n\n    public destroy(): void\n    {\n        this.bands.forEach((band: BiquadFilterNode) =>\n        {\n            band.disconnect();\n        });\n        (this as any).bands = null;\n        (this as any).bandsMap = null;\n    }\n}\n\nexport { EqualizerFilter };\n","import { getInstance } from '../instance';\nimport { Filter } from './Filter';\n\n/**\n * Filter for adding adding delaynode.\n *\n * @class\n * @memberof filters\n */\nclass DistortionFilter extends Filter\n{\n    /** The Wave shape node use to distort */\n    private _distortion: WaveShaperNode;\n\n    /** The amount of distoration */\n    private _amount: number;\n\n    /** @param {number} [amount=0] - The amount of distoration from 0 to 1. */\n    constructor(amount = 0)\n    {\n        if (getInstance().useLegacy)\n        {\n            super(null);\n\n            return;\n        }\n\n        const { context } = getInstance();\n        const distortion: WaveShaperNode = context.audioContext.createWaveShaper();\n\n        super(distortion);\n\n        this._distortion = distortion;\n\n        this.amount = amount;\n    }\n\n    /** @type {number} */\n    set amount(value: number)\n    {\n        value *= 1000;\n        this._amount = value;\n        const samples = 44100;\n        const curve: Float32Array = new Float32Array(samples);\n        const deg: number = Math.PI / 180;\n\n        let i = 0;\n        let x: number;\n\n        for (; i < samples; ++i)\n        {\n            x = (i * 2 / samples) - 1;\n            curve[i] = (3 + value) * x * 20 * deg / (Math.PI + (value * Math.abs(x)));\n        }\n        this._distortion.curve = curve;\n        this._distortion.oversample = '4x';\n    }\n    get amount(): number\n    {\n        return this._amount;\n    }\n\n    public destroy(): void\n    {\n        this._distortion = null;\n        super.destroy();\n    }\n}\n\nexport { DistortionFilter };\n","import { getInstance } from '../instance';\nimport { WebAudioUtils } from '../webaudio/WebAudioUtils';\nimport { Filter } from './Filter';\n\n/**\n * Filter for adding Stereo panning.\n *\n * @class\n * @memberof filters\n */\nclass StereoFilter extends Filter\n{\n    /** The stereo panning node */\n    private _stereo: StereoPannerNode;\n\n    /** The stereo panning node */\n    private _panner: PannerNode;\n\n    /** The amount of panning, -1 is left, 1 is right, 0 is centered */\n    private _pan: number;\n\n    /** @param {number} pan - The amount of panning, -1 is left, 1 is right, 0 is centered. */\n    constructor(pan = 0)\n    {\n        if (getInstance().useLegacy)\n        {\n            super(null);\n\n            return;\n        }\n\n        let stereo: StereoPannerNode;\n        let panner: PannerNode;\n        let destination: AudioNode;\n        const { audioContext } = getInstance().context;\n\n        if (audioContext.createStereoPanner)\n        {\n            stereo = audioContext.createStereoPanner();\n            destination = stereo;\n        }\n        else\n        {\n            panner = audioContext.createPanner();\n            panner.panningModel = 'equalpower';\n            destination = panner;\n        }\n\n        super(destination);\n\n        this._stereo = stereo;\n        this._panner = panner;\n\n        this.pan = pan;\n    }\n\n    /** Set the amount of panning, where -1 is left, 1 is right, and 0 is centered */\n    set pan(value: number)\n    {\n        this._pan = value;\n        if (this._stereo)\n        {\n            WebAudioUtils.setParamValue(this._stereo.pan, value);\n        }\n        else\n        {\n            this._panner.setPosition(value, 0, 1 - Math.abs(value));\n        }\n    }\n    get pan(): number\n    {\n        return this._pan;\n    }\n\n    public destroy(): void\n    {\n        super.destroy();\n        this._stereo = null;\n        this._panner = null;\n    }\n}\n\nexport { StereoFilter };\n","import { getInstance } from '../instance';\nimport { Filter } from './Filter';\n\n/**\n * Filter for adding reverb. Refactored from\n * https://github.com/web-audio-components/simple-reverb/\n *\n * @class\n * @memberof filters\n */\nclass ReverbFilter extends Filter\n{\n    private _seconds: number;\n    private _decay: number;\n    private _reverse: boolean;\n\n    /**\n     * @param seconds - Seconds for reverb\n     * @param decay - The decay length\n     * @param reverse - Reverse reverb\n     */\n    constructor(seconds = 3, decay = 2, reverse = false)\n    {\n        if (getInstance().useLegacy)\n        {\n            super(null);\n\n            return;\n        }\n\n        super(null);\n\n        this._seconds = this._clamp(seconds, 1, 50);\n        this._decay = this._clamp(decay, 0, 100);\n        this._reverse = reverse;\n        this._rebuild();\n    }\n\n    /**\n     * Clamp a value\n     * @param {number} value\n     * @param {number} min - Minimum value\n     * @param {number} max - Maximum value\n     * @return Clamped number\n     */\n    private _clamp(value: number, min: number, max: number): number\n    {\n        return Math.min(max, Math.max(min, value));\n    }\n\n    /**\n     * Length of reverb in seconds from 1 to 50\n     * @default 3\n     */\n    get seconds(): number\n    {\n        return this._seconds;\n    }\n    set seconds(seconds: number)\n    {\n        this._seconds = this._clamp(seconds, 1, 50);\n        this._rebuild();\n    }\n\n    /**\n     * Decay value from 0 to 100\n     * @default 2\n     */\n    get decay(): number\n    {\n        return this._decay;\n    }\n    set decay(decay: number)\n    {\n        this._decay = this._clamp(decay, 0, 100);\n        this._rebuild();\n    }\n\n    /**\n     * Reverse value from 0 to 1\n     * @default false\n     */\n    get reverse(): boolean\n    {\n        return this._reverse;\n    }\n    set reverse(reverse: boolean)\n    {\n        this._reverse = reverse;\n        this._rebuild();\n    }\n\n    /**\n     * Utility function for building an impulse response\n     * from the module parameters.\n     */\n    private _rebuild(): void\n    {\n        const context = getInstance().context.audioContext;\n        const rate: number = context.sampleRate;\n        const length: number = rate * this._seconds;\n        const impulse: AudioBuffer = context.createBuffer(2, length, rate);\n        const impulseL: Float32Array = impulse.getChannelData(0);\n        const impulseR: Float32Array = impulse.getChannelData(1);\n        let n: number;\n\n        for (let i = 0; i < length; i++)\n        {\n            n = this._reverse ? length - i : i;\n            impulseL[i] = ((Math.random() * 2) - 1) * Math.pow(1 - (n / length), this._decay);\n            impulseR[i] = ((Math.random() * 2) - 1) * Math.pow(1 - (n / length), this._decay);\n        }\n        const convolver = getInstance().context.audioContext.createConvolver();\n\n        convolver.buffer = impulse;\n        this.init(convolver);\n    }\n}\n\nexport { ReverbFilter };\n","import { getInstance } from '../instance';\nimport { Filter } from './Filter';\n\n/**\n * Combine all channels into mono channel.\n *\n * @class\n * @memberof filters\n */\nclass MonoFilter extends Filter\n{\n    /** Merger node */\n    private _merger: ChannelMergerNode;\n\n    constructor()\n    {\n        if (getInstance().useLegacy)\n        {\n            super(null);\n\n            return;\n        }\n        const audioContext: AudioContext = getInstance().context.audioContext;\n        const splitter: ChannelSplitterNode = audioContext.createChannelSplitter();\n        const merger: ChannelMergerNode = audioContext.createChannelMerger();\n\n        merger.connect(splitter);\n        super(merger, splitter);\n        this._merger = merger;\n    }\n\n    public destroy(): void\n    {\n        this._merger.disconnect();\n        this._merger = null;\n        super.destroy();\n    }\n}\n\nexport { MonoFilter };\n","import { getInstance } from '../instance';\nimport { WebAudioUtils } from '../webaudio/WebAudioUtils';\nimport { Filter } from './Filter';\n\n/**\n * Creates a telephone-sound filter.\n *\n * @class\n * @memberof filters\n */\nclass TelephoneFilter extends Filter\n{\n    constructor()\n    {\n        if (getInstance().useLegacy)\n        {\n            super(null);\n\n            return;\n        }\n\n        const { audioContext } = getInstance().context;\n        const lpf1 = audioContext.createBiquadFilter();\n        const lpf2 = audioContext.createBiquadFilter();\n        const hpf1 = audioContext.createBiquadFilter();\n        const hpf2 = audioContext.createBiquadFilter();\n\n        lpf1.type = 'lowpass';\n        WebAudioUtils.setParamValue(lpf1.frequency, 2000.0);\n\n        lpf2.type = 'lowpass';\n        WebAudioUtils.setParamValue(lpf2.frequency, 2000.0);\n\n        hpf1.type = 'highpass';\n        WebAudioUtils.setParamValue(hpf1.frequency, 500.0);\n\n        hpf2.type = 'highpass';\n        WebAudioUtils.setParamValue(hpf2.frequency, 500.0);\n\n        lpf1.connect(lpf2);\n        lpf2.connect(hpf1);\n        hpf1.connect(hpf2);\n\n        super(lpf1, hpf2);\n    }\n}\n\nexport { TelephoneFilter };\n","import { WebAudioMedia } from './WebAudioMedia';\nimport { WebAudioInstance } from './WebAudioInstance';\nimport { WebAudioNodes } from './WebAudioNodes';\nimport { WebAudioContext } from './WebAudioContext';\nimport { WebAudioUtils } from './WebAudioUtils';\n\n/**\n * Classes supporting non-WebAudio based browsers.\n * @namespace webaudio\n */\nexport default {\n    WebAudioMedia,\n    WebAudioInstance,\n    WebAudioNodes,\n    WebAudioContext,\n    WebAudioUtils\n};\n","import { getInstance } from '../instance';\n\n/**\n * Increment the alias for play once\n * @static\n * @default 0\n */\nlet PLAY_ID = 0;\n\n/**\n * Create a new \"Audio\" stream based on given audio path and project uri; returns the audio object.\n * @static\n * @param fileName - Full path of the file to play.\n * @param {Function} callback - Callback when complete.\n * @return New audio element alias.\n */\nfunction playOnce(url: string, callback?: (err?: Error) => void): string\n{\n    const alias = `alias${PLAY_ID++}`;\n\n    getInstance().add(alias, {\n        url,\n        preload: true,\n        autoPlay: true,\n        loaded: (err: Error) =>\n        {\n            if (err)\n            {\n                console.error(err);\n                getInstance().remove(alias);\n                if (callback)\n                {\n                    callback(err);\n                }\n            }\n        },\n        complete: () =>\n        {\n            getInstance().remove(alias);\n            if (callback)\n            {\n                callback(null);\n            }\n        },\n    });\n\n    return alias;\n}\n\nexport { playOnce, PLAY_ID };\n","import { playOnce } from './playOnce';\nimport { render } from './render';\nimport { resolveUrl } from './resolveUrl';\nimport { sineTone } from './sineTone';\nimport { supported, extensions, validateFormats } from './supported';\n\n/**\n * Utilities that work with sounds.\n * @namespace utils\n */\nexport default {\n    playOnce,\n    render,\n    resolveUrl,\n    sineTone,\n    supported,\n    extensions,\n    validateFormats\n};\n","import { BaseTexture } from '@pixi/core';\nimport { Sound } from '../Sound';\nimport { WebAudioMedia } from '../webaudio/WebAudioMedia';\n\ninterface RenderOptions {\n    width?: number;\n    height?: number;\n    fill?: string | CanvasPattern | CanvasGradient;\n}\n\n/**\n * Render image as Texture. **Only supported with WebAudio**\n * @static\n * @param {Sound} sound - Instance of sound to render\n * @param {Object} [options] - Custom rendering options\n * @param {number} [options.width=512] - Width of the render\n * @param {number} [options.height=128] - Height of the render\n * @param {string|CanvasPattern|CanvasGradient} [options.fill='black'] - Fill style for waveform\n * @return Result texture\n */\nfunction render(sound: Sound, options?: RenderOptions): BaseTexture\n{\n    const canvas: HTMLCanvasElement = document.createElement('canvas');\n\n    options = {\n        width: 512,\n        height: 128,\n        fill: 'black', ...(options || {}) };\n\n    canvas.width = options.width;\n    canvas.height = options.height;\n\n    const baseTexture = BaseTexture.from(canvas);\n\n    if (!(sound.media instanceof WebAudioMedia))\n    {\n        return baseTexture;\n    }\n\n    const media: WebAudioMedia = sound.media as WebAudioMedia;\n\n    // eslint-disable-next-line no-console\n    console.assert(!!media.buffer, 'No buffer found, load first');\n\n    const context: CanvasRenderingContext2D = canvas.getContext('2d');\n\n    context.fillStyle = options.fill;\n    const data: Float32Array = media.buffer.getChannelData(0);\n    const step: number = Math.ceil(data.length / options.width);\n    const amp: number = options.height / 2;\n\n    for (let i = 0; i < options.width; i++)\n    {\n        let min = 1.0;\n        let max = -1.0;\n\n        for (let j = 0; j < step; j++)\n        {\n            const datum: number = data[(i * step) + j];\n\n            if (datum < min)\n            {\n                min = datum;\n            }\n            if (datum > max)\n            {\n                max = datum;\n            }\n        }\n        context.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));\n    }\n\n    return baseTexture;\n}\n\nexport type { RenderOptions };\nexport { render };\n","import { Sound } from '../Sound';\nimport { WebAudioMedia } from '../webaudio/WebAudioMedia';\nimport { WebAudioContext } from '../webaudio/WebAudioContext';\n\n/**\n * Create a new sound for a sine wave-based tone.  **Only supported with WebAudio**\n * @static\n * @param {number} [hertz=200] - Frequency of sound.\n * @param {number} [seconds=1] - Duration of sound in seconds.\n * @return New sound.\n */\nfunction sineTone(hertz = 200, seconds = 1): Sound\n{\n    const sound = Sound.from({\n        singleInstance: true,\n    });\n\n    if (!(sound.media instanceof WebAudioMedia))\n    {\n        return sound;\n    }\n\n    const media = sound.media as WebAudioMedia;\n    const context = sound.context as WebAudioContext;\n\n    // set default value\n    const nChannels = 1;\n    const sampleRate = 48000;\n    const amplitude = 2;\n\n    // create the buffer\n    const buffer = context.audioContext.createBuffer(\n        nChannels,\n        seconds * sampleRate,\n        sampleRate,\n    );\n    const fArray = buffer.getChannelData(0);\n\n    // fill the buffer\n    for (let i = 0; i < fArray.length; i++)\n    {\n        const time  = i / buffer.sampleRate;\n        const angle = hertz * time * Math.PI;\n\n        fArray[i] = Math.sin(angle) * amplitude;\n    }\n\n    // set the buffer\n    media.buffer = buffer;\n    sound.isLoaded = true;\n\n    return sound;\n}\n\nexport { sineTone };\n","import { Loader } from '@pixi/loaders';\nimport { setInstance } from './instance';\nimport { SoundLoader } from './SoundLoader';\nimport { SoundLibrary } from './SoundLibrary';\nimport htmlaudio from './htmlaudio';\nimport filters from './filters';\nimport webaudio from './webaudio';\nimport utils from './utils';\n\nconst sound = setInstance(new SoundLibrary());\n\n// Add the loader plugin\nLoader.registerPlugin(SoundLoader);\n\nexport * from './Sound';\nexport * from './SoundLoader';\nexport * from './SoundLibrary';\nexport * from './Filterable';\nexport * from './interfaces';\nexport * from './filters/Filter';\nexport * from './SoundSprite';\nexport {\n    sound,\n    htmlaudio,\n    filters,\n    webaudio,\n    utils,\n};\n","import {\n    sound,\n    Filterable,\n    Sound,\n    SoundLibrary,\n    SoundSprite,\n    SoundLoader,\n    filters,\n    htmlaudio,\n    utils,\n    webaudio } from './index';\n\nObject.defineProperties(sound,\n    {\n        Filterable: { get() { return Filterable; } },\n        filters: { get() { return filters; } },\n        htmlaudio: { get() { return htmlaudio; } },\n        Sound: { get() { return Sound; } },\n        SoundLoader: { get() { return SoundLoader; } },\n        SoundLibrary: { get() { return SoundLibrary; } },\n        SoundSprite: { get() { return SoundSprite; } },\n        utils: { get() { return utils; } },\n        webaudio: { get() { return webaudio; } },\n        sound: { get() { return sound; } },\n    });\n\n/**\n * For browser bundle, we'll wrap everything in a single default export.\n * This will be accessible from `PIXI.sound`. For the ESM/CJS bundles\n * we export everything as named.\n * @ignore\n */\nexport default sound;\n\n"],"names":["instance","getInstance","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","extensions","supported","validateFormats","typeOverrides","overrides","m4a","oga","opus","caf","audio","document","createElement","formats","no","forEach","ext","canByExt","canPlayType","replace","canByType","FORMAT_PATTERN","resolveUrl","source","glob","url","test","match","exec","exts","split","len","resolved","writableSource","extension","SoundLoader","setLegacy","useLegacy","legacy","LoaderResource","setExtensionXhrType","XHR_RESPONSE_TYPE","DEFAULT","setExtensionLoadType","LOAD_TYPE","AUDIO","BUFFER","XHR","resource","next","data","indexOf","sound","add","name","loaded","preload","id","parent","_super","_this","init","HTMLAudioInstance","value","undefined","Error","speed","volume","paused","loop","muted","_source","_duration","_paused","refreshPaused","_playing","media","duration","cloneNode","src","onplay","_onPlay","bind","onpause","_onPause","context","on","refresh","_media","onended","pause","_internalStop","emit","_speed","_volume","_loop","_muted","global","globalVolume","soundVolume","instanceVolume","playbackRate","pausedReal","_pausedReal","play","start","currentTime","end","_end","options","_start","Math","max","PADDING","min","onloadedmetadata","Ticker","shared","_onUpdate","_onComplete","progress","remove","removeAllListeners","off","EventEmitter","HTMLAudioMedia","Audio","readyState","_filters","load","callback","onLoad","removeListeners","isLoaded","autoPlayStart","onAbort","onError","message","error","code","removeEventListener","addEventListener","instance_1","setTimeout","SoundSprite","complete","WebAudioUtils","param","setValueAtTime","context_1","audioContext","_elapsed","WebAudioInstance","_update","setParamValue","_gain","gain","_a","nodes","cloneBufferSource","buffer","_lastUpdate","_now","loopEnd","loopStart","enableTicker","enabled","_updateListener","_progress","disconnect","events","force","now","delta","soundLength","stop","err","input","output","_output","_input","Filterable","filters","filter","connect","slice","prevFilter_1","destination","bufferSource","createBufferSource","createGain","analyser","createAnalyser","WebAudioNodes","_script","createScriptProcessor","BUFFER_SIZE","destroy","orig","script","bufferSize","WebAudioMedia","_nodes","_decode","_loadUrl","request","XMLHttpRequest","open","responseType","onload","response","send","arrayBuffer","decode","_instances","_sprites","_autoPlayOptions","isPlaying","autoPlay","singleInstance","sprites","addSprites","_preload","Sound","ArrayBuffer","HTMLAudioElement","freeze","results","alias","sprite","_removeInstances","removeSprites","name_1","isPlayable","offset","Promise","resolve","reject","_createInstance","push","once","_poolInstance","index","splice","_pool","pop","HTMLAudioContext","win","window","ctx","WebAudioContext","AudioContext","compressor","createDynamicsCompressor","_ctx","_offlineCtx","OfflineAudioContext","sampleRate","_unlocked","state","_unlock","playEmptySound","createBuffer","resume","webkitAudioContext","webkitOfflineAudioContext","close","suspend","handleError","result","decodeAudioData","catch","SoundLibrary","_webAudioContext","_htmlAudioContext","_sounds","_context","filtersAll","sourceOptions","options_1","_getOptions","from","_useLegacy","exists","togglePause","toggleMute","assert","find","removeAll","Filter","EqualizerFilter","f32","f64","f125","f250","f500","f1k","f2k","f4k","f8k","f16k","bands","f","F32","type","F64","F125","F250","F500","F1K","F2K","F4K","F8K","F16K","map","band","node","createBiquadFilter","Q","frequency","bandsMap","getGain","setGain","DistortionFilter","amount","distortion","createWaveShaper","_distortion","_amount","x","samples","curve","Float32Array","deg","PI","abs","oversample","StereoFilter","pan","stereo","panner","createStereoPanner","createPanner","panningModel","_stereo","_panner","_pan","setPosition","ReverbFilter","seconds","decay","reverse","_seconds","_clamp","_decay","_reverse","_rebuild","rate","impulse","impulseL","getChannelData","impulseR","random","pow","convolver","createConvolver","MonoFilter","splitter","createChannelSplitter","merger","createChannelMerger","_merger","TelephoneFilter","lpf1","lpf2","hpf1","hpf2","PLAY_ID","playOnce","render","canvas","width","height","fill","baseTexture","BaseTexture","getContext","fillStyle","step","ceil","amp","j","datum","fillRect","sineTone","hertz","fArray","angle","sin","setInstance","registerPlugin","defineProperties","get","htmlaudio","utils","webaudio"],"mappings":"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"}