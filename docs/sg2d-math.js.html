<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: sg2d-math.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: sg2d-math.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * SG2DMath
 * https://github.com/VediX/sg2d.github.io
 * (c) Kalashnikov Ilya
 */

"use strict";

let SG2DMath = {};

export default SG2DMath;
	
(function() {

	let _uid = 0;
	SG2DMath.uid = function() {
		return (++_uid);
	};
	
	// Functions for working with bitmasks
	SG2DMath.addFlag = (value, flag)=>(value | flag);
	SG2DMath.removeFlag = (value, flag)=>(value &amp; ~flag);
	SG2DMath.setFlag = (value, flag, state = true)=>(state ? SG2DMath.addFlag(value, flag) : SG2DMath.removeFlag(value, flag));
	SG2DMath.hasFlag = (value, flag)=>(value &amp; flag);
	SG2DMath.noFlag = (value, flag)=>(! (value &amp; flag));
	
	let _ap = [];
	for (var dec = 0; dec &lt;= 10; dec++) _ap[dec] = 10 ** dec;
	
	/**
	 * Round to decimal place
	 * @param {number} v
	 * @param {int} p
	 * @returns {number}
	 */
	SG2DMath.roundTo = function(v, dec) {
		var e = _ap[dec];
		return Math.round(v * e) / e;
	};
	
	SG2DMath.absDelta = function(v1, v2) {
		return Math.abs(v1 - v2);
	};

	SG2DMath.PI180 = Math.PI/180;
	SG2DMath.PI2 = Math.PI*2;
	SG2DMath.rad90 = 90 * SG2DMath.PI180;

	SG2DMath.toRad = function(a) {
		return a * this.PI180;
	};
	
	SG2DMath.toDeg = function(a) {
		return a / this.PI180;
	};
	
	SG2DMath.normalize_a = function(a, precision = 0) {
		while (a >= 360) a = a - 360;
		while (a &lt; 0) a = a + 360;
		return this.roundTo(a, precision);
	};

	let _aSin = [];
	let _aCos = [];
	for (var a = 0; a &lt;= 360; a++) {
		_aSin[a] = Math.sin(a * SG2DMath.PI180);
		_aCos[a] = Math.cos(a * SG2DMath.PI180);
	}
	let _aSin1 = [];
	let _aCos1 = [];
	for (var a = 0; a &lt;= 3600; a++) {
		var _a = a / 10;
		_aSin1[a] = Math.sin(_a * SG2DMath.PI180);
		_aCos1[a] = Math.cos(_a * SG2DMath.PI180);
	}
	
	SG2DMath.sin = function(a, precision = 0) { // Accuracy to the tenth of a degree
		return (precision === 0 ? _aSin[this.normalize_a(a, precision)] : _aSin1[ Math.round(10 * this.normalize_a(a, 1)) ]);
	};
	SG2DMath.cos = function(a, precision = 0) {
		return (precision === 0 ? _aCos[this.normalize_a(a, precision)] : _aCos1[ Math.round(10 * this.normalize_a(a, 1)) ]);
	};
	
	SG2DMath.sinrad = function() {
		arguments[0] = arguments[0] / this.PI180;
		return this.sin.apply(this, arguments);
	};
	
	SG2DMath.cosrad = function() {
		arguments[0] = arguments[0] / this.PI180;
		return this.cos.apply(this, arguments);
	};
	
	/*Math.angle_p1p2_rad = function(p1, p2) { //not used!
		return Math.atan2(p2.y - p1.y, p2.x - p1.x);
	};*/
	SG2DMath.angle_p1p2_deg = function(p1, p2, precision = 0) {
		var angle_rad = Math.atan2(p2.y - p1.y, p2.x - p1.x);
		var angle_deg = this.normalize_a(angle_rad / this.PI180, precision);
		return angle_deg;
	};

	SG2DMath.distance_d = function(dx, dy) {
		return Math.sqrt(dx*dx + dy*dy);
	};
	SG2DMath.distance_p = function(p1, p2) {
		return Math.sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y));
	};
	
	// Get the minimum angle to get from a_start a_end
	SG2DMath.betweenAnglesDeg = function(a_start, a_end) {
		var da1 = a_end - a_start;
		var da2 = (a_end-360) - a_start;
		var da3 = a_end - (a_start-360);
		return (Math.abs(da1) &lt; Math.abs(da2) ? (Math.abs(da3) &lt; Math.abs(da1) ? da3 : da1) : (Math.abs(da3) &lt; Math.abs(da2) ? da3 : da2));
	};

	// Direction of rotation (right / left) - which is faster
	SG2DMath.nearestDirRotate = function(rotate_current, rotate_target) {
		var a1 = this.normalize_a(rotate_target - rotate_current);
		var a2 = this.normalize_a(rotate_current - rotate_target);
		if (a1 === a2) return 0;
		return a1 > a2 ? -1 : 1;
	};
	
	SG2DMath.vectors45 = [{dx:1,dy:0},{dx:1,dy:1},{dx:0,dy:1},{dx:-1,dy:1},{dx:-1,dy:0},{dx:-1,dy:-1},{dx:0,dy:-1},{dx:1,dy:-1}]; // counterclockwise, starting from 0 deg
	SG2DMath.vectors90 = [{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0},{dx:0,dy:-1}]; // counterclockwise, starting from 0 deg

	/** @private */
	let _linePoints = [];
	/**
	 * Default point collection function
	 * @private
	 */
	SG2DMath._addLinePoint = function(x, y) {
		this.push({x: x, y: y});
	};
	
	/**
	* Forming an array of points of a solid line
	* @param {object} oPointStart
	* @param {object} oPointEnd
	* @param {mixed} dest fAddLinePoint or aDest or undefined
	* @return {array}
	*/
	SG2DMath.getLinePoints = function(oPointStart, oPointEnd, dest = void 0) {
		
		var fAddLinePoint = this._addLinePoint;
		if (typeof dest === "function") fAddLinePoint = dest;
		else if (Array.isArray(dest)) fAddLinePoint = fAddLinePoint.bind(dest);
		else (_linePoints.length = 0, fAddLinePoint = fAddLinePoint.bind(_linePoints));
		
		fAddLinePoint(Math.round(oPointStart.x), Math.round(oPointStart.y));

		var x1 = oPointStart.x, y1 = oPointStart.y;
		var x2 = oPointEnd.x, y2 = oPointEnd.y;
		var Dx = (x2 - x1), Dy = (y2 - y1);
		var d = Math.sqrt(Dx*Dx + Dy*Dy);
		var dx = Dx / d, dy = Dy / d;
		var cx = x1, cy = y1;
		var cxPrev = Math.round(x1), cyPrev = Math.round(y1);
		var cxIntPrev = cxPrev, cyIntPrev = cyPrev;

		while (true) {
			cx += dx;
			cy += dy;

			var cxInt = Math.round(cx);
			var cyInt = Math.round(cy);

			if ( (cxInt === cxIntPrev) &amp;&amp; (cyInt === cyIntPrev) ) continue;
			if ( ( (x2 > x1) &amp;&amp; (cx > x2) ) || ( (x2 &lt; x1) &amp;&amp; (cx &lt; x2) ) ) break;
			if ( ( (y2 > y1) &amp;&amp; (cy > y2) ) || ( (y2 &lt; y1) &amp;&amp; (cy &lt; y2) ) ) break;
			if ( (cxInt != cxIntPrev) &amp;&amp; (cyInt != cyIntPrev) ) {
				var cx1Int = cxInt;
				var cy1Int = cyIntPrev;
				var d1 = Math.sqrt( Math.pow(cx1Int - cx, 2) + Math.pow(cy1Int - cy, 2) ) + Math.sqrt( Math.pow(cx1Int - cxPrev, 2) + Math.pow(cy1Int - cyPrev, 2) );
				var cx2Int = cxIntPrev;
				var cy2Int = cyInt;
				var d2 = Math.sqrt( Math.pow(cx2Int - cx, 2) + Math.pow(cy2Int - cy, 2) ) + Math.sqrt( Math.pow(cx2Int - cxPrev, 2) + Math.pow(cy2Int - cyPrev, 2) );
				if (d1 > d2) {
					fAddLinePoint(cx2Int, cy2Int);
					cxIntPrev = cx2Int;
					cyIntPrev = cy2Int;
				} else {
					fAddLinePoint(cx1Int, cy1Int);
					cxIntPrev = cx1Int;
					cyIntPrev = cy1Int;
				}
			}

			fAddLinePoint(cxInt, cyInt);

			cxPrev = cx;
			cyPrev = cy;
			cxIntPrev = cxInt;
			cyIntPrev = cyInt;
		}
		
		return _linePoints;
	};
	
	let _avgVertext = {x: void 0, y: void 0};
	
	/**
	 * Get the midpoint
	 * @param {array} vertexes
	 * @param {object} point
	 * @returns {object} return point object
	 */
	SG2DMath.avgVertext = function(vertexes, point) {
		if (! vertexes.length) { debugger; throw "Error 773734";}
		point = point || _avgVertext;
		_avgVertext.x = vertexes[0].x;
		_avgVertext.y = vertexes[0].y;
		for (var i = 1; i &lt; vertexes.length; i++) {
			_avgVertext.x += vertexes[i].x;
			_avgVertext.y += vertexes[i].y;
		}
		_avgVertext.x = _avgVertext.x / vertexes.length;
		_avgVertext.y = _avgVertext.y / vertexes.length;
		return _avgVertext;
	};
})();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="SG2D.html">SG2D</a></li><li><a href="SG2D.Fonts.html">Fonts</a></li><li><a href="SG2D.MessageToast.html">MessageToast</a></li><li><a href="SG2D.Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="SG2D.Application.html">Application</a></li><li><a href="SG2D.Bounds.html">Bounds</a></li><li><a href="SG2D.Camera.html">Camera</a></li><li><a href="SG2D.Cluster.html">Cluster</a></li><li><a href="SG2D.Clusters.html">Clusters</a></li><li><a href="SG2D.CustomSprite.html">CustomSprite</a></li><li><a href="SG2D.Effects.html">Effects</a></li><li><a href="SG2D.Label.html">Label</a></li><li><a href="SG2D.LabelCanvas.html">LabelCanvas</a></li><li><a href="SG2D.PluginBase.html">PluginBase</a></li><li><a href="SG2D.Plugins.html">Plugins</a></li><li><a href="SG2D.Pointer.html">Pointer</a></li><li><a href="SG2D.Sound.html">Sound</a></li><li><a href="SG2D.Tile.html">Tile</a></li><li><a href="SG2D.TileBody.html">TileBody</a></li><li><a href="SG2DTransitions.html">SG2DTransitions</a></li><li><a href="SGModel.html">SGModel</a></li><li><a href="SGModelView.html">SGModelView</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Tue Sep 14 2021 20:39:17 GMT+0200 (Восточная Европа, стандартное время)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
